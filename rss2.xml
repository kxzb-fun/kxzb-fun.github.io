<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>sharpmind.tech</title>
    <link>https://sharpmind.tech/</link>
    
    <image>
      <url>https://sharpmind.tech/img/favicon.ico</url>
      <title>sharpmind.tech</title>
      <link>https://sharpmind.tech/</link>
    </image>
    
    <atom:link href="https://sharpmind.tech/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>一个分享技术、读书笔记和提升认知以及终身成长的博客。</description>
    <pubDate>Sun, 04 Jan 2026 11:58:29 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>如何提取网站流媒体音频 DASH（.m4s）文件</title>
      <link>https://sharpmind.tech/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8F%96%E7%BD%91%E7%AB%99%E6%B5%81%E5%AA%92%E4%BD%93%E9%9F%B3%E9%A2%91-m4s-%E6%96%87%E4%BB%B6/</link>
      <guid>https://sharpmind.tech/%E5%A6%82%E4%BD%95%E6%8F%90%E5%8F%96%E7%BD%91%E7%AB%99%E6%B5%81%E5%AA%92%E4%BD%93%E9%9F%B3%E9%A2%91-m4s-%E6%96%87%E4%BB%B6/</guid>
      <pubDate>Sat, 03 Jan 2026 07:42:54 GMT</pubDate>
      
      <description>如何从 DASH 流中提取音频 m4s 文件，合并为完整音频文件。解决无法从页面下载 mp3 的问题。</description>
      
      
      
      <content:encoded><![CDATA[<p>在尝试下载某些网页上的音频时，你可能会发现一个奇怪的现象：</p><ul><li>没有 mp3</li><li>Network 里全是 <code>.m4s</code></li><li>单个文件无法播放</li></ul><p>本文记录一次<strong>完整解决过程</strong>，解释问题的本质，并给出稳定可行的下载方案。</p><h2 id="一、问题现象"><a href="#一、问题现象" class="headerlink" title="一、问题现象"></a>一、问题现象</h2><p>在某些网页中查看请求文件，音频地址类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://example.com/audio_eng_1=96000-7.m4s</span><br><span class="line">https://example.com/audio_eng_1=96000-8.m4s</span><br><span class="line">https://example.com/audio_eng_1=96000-9.m4s</span><br></pre></td></tr></table></figure><p>这些文件：</p><ul><li>不是 mp3</li><li>不是完整音频</li><li>单独下载后无法正常播放</li></ul><p>使用 yt-dlp 直接下载页面：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp https://example.com/</span><br></pre></td></tr></table></figure><p>会得到类似错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Unable to extract playlist data</span><br></pre></td></tr></table></figure><p>明白 👍<br>下面是一篇<strong>可以直接发布的 Markdown 博客文章</strong>，结构完整、逻辑清晰，适合技术博客 &#x2F; 笔记站 &#x2F; Notion &#x2F; GitHub Pages。<br>内容聚焦<strong>问题 → 原因 → 解决方案 → 总结</strong>，不啰嗦。</p><hr><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 从 BBC 网页音频到完整文件：一次 DASH（.m4s）音频下载的完整实践</span></span><br><span class="line"></span><br><span class="line">在尝试下载 BBC Learning English 网页上的音频时，你可能会发现一个奇怪的现象：</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> 没有 mp3</span><br><span class="line"><span class="bullet">-</span> Network 里全是 <span class="code">`.m4s`</span></span><br><span class="line"><span class="bullet">-</span> 单个文件无法播放</span><br><span class="line"><span class="bullet">-</span> yt-dlp 直接下载网页还会报错</span><br><span class="line"></span><br><span class="line">本文记录一次<span class="strong">**完整、可复现的解决过程**</span>，解释问题的本质，并给出稳定可行的下载方案。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="section">## 一、问题现象</span></span><br><span class="line"></span><br><span class="line">在 BBC Learning English 页面中，音频地址类似：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>…audio_eng_1&#x3D;96000-7.m4s<br>…audio_eng_1&#x3D;96000-9.m4s</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这些文件：</span><br><span class="line"></span><br><span class="line">- 不是 mp3</span><br><span class="line">- 不是完整音频</span><br><span class="line">- 单独下载后无法正常播放</span><br><span class="line"></span><br><span class="line">使用 yt-dlp 直接下载页面：</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">yt-dlp https://www.bbc.co.uk/learningenglish/...</span><br></pre></td></tr></table></figure><p>会得到类似错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Unable to extract playlist data</span><br></pre></td></tr></table></figure><hr><h2 id="二、问题本质：这不是文件，而是流"><a href="#二、问题本质：这不是文件，而是流" class="headerlink" title="二、问题本质：这不是文件，而是流"></a>二、问题本质：这不是文件，而是流</h2><p>网页中使用的是 <strong>MPEG-DASH（DASH）流媒体</strong> 技术。</p><h3 id="1-什么是-m4s"><a href="#1-什么是-m4s" class="headerlink" title="1. 什么是 .m4s"></a>1. 什么是 <code>.m4s</code></h3><ul><li><code>.m4s</code> 是 <strong>MPEG-4 Segment</strong></li><li>每个文件只有几秒钟的音频</li><li>播放器会连续下载并拼接这些分片</li></ul><p>👉 <code>.m4s</code> 本身 <strong>永远不是目标</strong></p><h3 id="2-真正的关键文件：-mpd"><a href="#2-真正的关键文件：-mpd" class="headerlink" title="2. 真正的关键文件：.mpd"></a>2. 真正的关键文件：<code>.mpd</code></h3><ul><li><p><code>.mpd</code> 是 DASH 的 <strong>播放清单（Manifest）</strong></p></li><li><p>描述了：</p><ul><li>所有音频分片的顺序</li><li>可用码率</li><li>音轨信息</li></ul></li></ul><p>播放器、ffmpeg、yt-dlp 都是通过 <code>.mpd</code> 才能还原完整音频。</p><h2 id="三、关键细节：必须点击「播放」"><a href="#三、关键细节：必须点击「播放」" class="headerlink" title="三、关键细节：必须点击「播放」"></a>三、关键细节：必须点击「播放」</h2><p>一个容易忽略但非常重要的点：</p><blockquote><p><strong>必须先点击网页上的音频播放按钮</strong></p></blockquote><p>原因是：</p><ul><li><p>一些网页的音频流是 <strong>播放时才加载</strong></p></li><li><p>不点击播放：</p><ul><li>Network 面板中看不到 <code>.mpd</code></li></ul></li><li><p>点击播放后：</p><ul><li><code>.mpd</code> 请求才会出现</li></ul></li></ul><h2 id="四、正确的下载流程"><a href="#四、正确的下载流程" class="headerlink" title="四、正确的下载流程"></a>四、正确的下载流程</h2><h3 id="Step-1：获取-mpd-地址"><a href="#Step-1：获取-mpd-地址" class="headerlink" title="Step 1：获取 .mpd 地址"></a>Step 1：获取 <code>.mpd</code> 地址</h3><ol><li><p>打开音频页面</p></li><li><p>打开浏览器开发者工具（F12）</p></li><li><p>进入 <strong>Network</strong></p></li><li><p>点击页面中的 <strong>播放按钮</strong></p></li><li><p>在过滤框中输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.mpd</span><br></pre></td></tr></table></figure></li><li><p>复制完整的 <code>.mpd</code> URL</p></li></ol><h3 id="Step-2：下载并合并音频"><a href="#Step-2：下载并合并音频" class="headerlink" title="Step 2：下载并合并音频"></a>Step 2：下载并合并音频</h3><h4 id="方案-A：使用-ffmpeg（推荐）"><a href="#方案-A：使用-ffmpeg（推荐）" class="headerlink" title="方案 A：使用 ffmpeg（推荐）"></a>方案 A：使用 ffmpeg（推荐）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i <span class="string">&quot;复制的.mpd链接&quot;</span> -c copy output.m4a</span><br></pre></td></tr></table></figure><ul><li>自动下载所有 <code>.m4s</code></li><li>自动按顺序合并</li><li>保留原始音质</li></ul><h4 id="方案-B：使用-yt-dlp"><a href="#方案-B：使用-yt-dlp" class="headerlink" title="方案 B：使用 yt-dlp"></a>方案 B：使用 yt-dlp</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yt-dlp <span class="string">&quot;复制的.mpd链接&quot;</span></span><br></pre></td></tr></table></figure><p>直接输出完整音频文件。</p><h3 id="（可选）转成-mp3"><a href="#（可选）转成-mp3" class="headerlink" title="（可选）转成 mp3"></a>（可选）转成 mp3</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i output.m4a -acodec libmp3lame -b:a 128k output.mp3</span><br></pre></td></tr></table></figure><hr><h2 id="五、经验总结"><a href="#五、经验总结" class="headerlink" title="五、经验总结"></a>五、经验总结</h2><ul><li><code>.m4s</code> 只是碎片，不是目标</li><li><code>.mpd</code> 才是完整音频的入口</li><li>必须点击播放才能抓到 <code>.mpd</code></li><li>ffmpeg &#x2F; yt-dlp 都可以直接处理 <code>.mpd</code></li><li>对于 DASH 流，<strong>绕过网页，直取清单文件最稳</strong></li></ul><h2 id="六、适用范围"><a href="#六、适用范围" class="headerlink" title="六、适用范围"></a>六、适用范围</h2><p>本文方法适用于：</p><ul><li>使用 Akamai CDN 的音频网站</li><li>所有基于 MPEG-DASH 的音频流</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>当网页上“没有 mp3”时，往往不是资源不存在，而是<strong>呈现方式变了</strong>。</p><p>理解流媒体的工作方式，比记住某个下载工具更重要。</p>]]></content:encoded>
      
      
      <category domain="https://sharpmind.tech/categories/%E9%9F%B3%E9%A2%91%E6%8F%90%E5%8F%96/">音频提取</category>
      
      
      <category domain="https://sharpmind.tech/tags/%E6%B5%81%E5%AA%92%E4%BD%93/">流媒体</category>
      
      <category domain="https://sharpmind.tech/tags/%E9%9F%B3%E9%A2%91%E6%8F%90%E5%8F%96/">音频提取</category>
      
      <category domain="https://sharpmind.tech/tags/DASH/">DASH</category>
      
      <category domain="https://sharpmind.tech/tags/m4s/">m4s</category>
      
      <category domain="https://sharpmind.tech/tags/yt-dlp/">yt-dlp</category>
      
      <category domain="https://sharpmind.tech/tags/ffmpeg/">ffmpeg</category>
      
      
    </item>
    
    <item>
      <title>年终总结 40 问</title>
      <link>https://sharpmind.tech/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93-40-%E9%97%AE/</link>
      <guid>https://sharpmind.tech/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93-40-%E9%97%AE/</guid>
      <pubDate>Wed, 31 Dec 2025 12:53:37 GMT</pubDate>
      
      <description>年终总结 40 问模板，作为回顾每年的的 40 个问题。</description>
      
      
      
      <content:encoded><![CDATA[<p>年终总结 40 问模板，作为回顾每年的的 40 个问题。<br>2025 年即将过去，2026 年将开始。</p><ol><li>你今年做了哪些之前从未做过的事？</li><li>你有没有遵守年初时和自己许下的约定？</li><li>你身边有人生孩子了吗？</li><li>你身边有人去世了吗？</li><li>你去了哪些城市&#x2F;州&#x2F;国家？</li><li>明年你想要获得哪些你今年没有的东西？</li><li>今年的哪个或哪些日子会铭刻在你的记忆中，为什么？</li><li>你今年最大的成就是什么？</li><li>你今年最大的失败是什么？</li><li>你今年还遇到过哪些困难？</li><li>你今年是否生过病或受过伤？</li><li>你今年买过的最好的东西是什么？</li><li>谁的行为值得去表扬？</li><li>谁的行为令你感到震惊？</li><li>你大部分的钱都花到哪里去了？</li><li>有什么事让你感到超级、超级、超级兴奋？</li><li>哪首歌会永远让你想起这一年？</li><li>与去年的这个时候相比，你是：感到更快乐还是更悲伤了？变得更瘦还是更胖了？变得更富还是更穷了？</li><li>你希望自己能做得更多的是什么？</li><li>你希望自己能做得更少的是什么？</li><li>你是如何度过节假日的？</li><li>你今年坠入爱河了吗？</li><li>你是否有讨厌某个你去年此时不觉得讨厌的人呢？</li><li>你最喜欢的电视节目是什么？</li><li>你读过最好的一本书是什么？</li><li>你今年发现的最好听的一首歌是什么？</li><li>你今年看过最喜欢的一部电影是什么？</li><li>你今年吃过最好吃的一顿饭是什么？</li><li>有什么是你想要且得到了的？</li><li>有什么是你想要却没有得到的？</li><li>你生日那天做了什么？</li><li>有什么还未发生的事，如果发生了，会让你的这一年变得无比满足?</li><li>你会如何描述你今年的个人时尚风格？</li><li>是什么让你保持理智？</li><li>你最欣赏哪个名人&#x2F;公众人物？</li><li>哪个政治问题最令你有感而发？</li><li>你想念哪些人？</li><li>在你新认识的人之中，谁是最好的？</li><li>今年你学到了什么宝贵的人生经验？</li><li>能够总结你这一年的一句话是什么？</li></ol>]]></content:encoded>
      
      
      <category domain="https://sharpmind.tech/categories/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/">年终总结</category>
      
      
      <category domain="https://sharpmind.tech/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/">年终总结</category>
      
      
    </item>
    
    <item>
      <title>编写rust猜数游戏</title>
      <link>https://sharpmind.tech/rust/%E7%BC%96%E5%86%99rust%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/</link>
      <guid>https://sharpmind.tech/rust/%E7%BC%96%E5%86%99rust%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/</guid>
      <pubDate>Sat, 20 Dec 2025 03:56:22 GMT</pubDate>
      
      <description>初步认识Rust，完成一个经典的猜数游戏，玩家需要猜出一个随机生成的1到100之间的整数。知识点解析。</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="猜数游戏"><a href="#猜数游戏" class="headerlink" title="猜数游戏"></a>猜数游戏</h2><p>这是一个经典的猜数游戏，玩家需要猜出一个随机生成的1到100之间的整数。<br>用户输入一个猜测的数字，程序会告诉用户猜测的数字是过高、过低还是正确。<br>玩家需要不断猜测，直到猜对为止。</p><h3 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> rand::Rng;</span><br><span class="line"><span class="keyword">use</span> std::io;</span><br><span class="line"><span class="comment">// 增加了另一个 use 声明，从标准库引入了一个叫做 std::cmp::Ordering 的类型到作用域中。</span></span><br><span class="line"><span class="comment">// Ordering 也是一个枚举，不过它的成员是 Less、Greater 和 Equal。</span></span><br><span class="line"><span class="keyword">use</span> std::cmp::Ordering;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="comment">// 生成一个1-100内的随机数</span></span><br><span class="line">    <span class="comment">// cargo add rand (crate)</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">secret_number</span> = rand::<span class="title function_ invoke__">rng</span>().<span class="title function_ invoke__">random_range</span>(<span class="number">1</span>..=<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;secret number is &#123;&#125;&quot;</span>, secret_number);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;let&#x27;s play a game!&quot;</span>);</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;please guess a number between 1 and 100:&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取用户输入的数据</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user_guess</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        io::<span class="title function_ invoke__">stdin</span>()</span><br><span class="line">            .<span class="title function_ invoke__">read_line</span>(&amp;<span class="keyword">mut</span> user_guess)</span><br><span class="line">            .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Failed to read line&quot;</span>);</span><br><span class="line">        <span class="comment">// let user_guess: u32 = user_guess.trim().parse().expect(&quot;Please type a number!&quot;);</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">user_guess</span>: <span class="type">u32</span> =<span class="keyword">match</span> user_guess.<span class="title function_ invoke__">trim</span>().<span class="title function_ invoke__">parse</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(num)=&gt;num,</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(_)=&gt;<span class="keyword">continue</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;your guess number is &#123;user_guess&#125;!&quot;</span>);</span><br><span class="line">        <span class="comment">// 用户输入和随机数比较</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> &amp;</span></span><br><span class="line">        <span class="keyword">match</span> user_guess.<span class="title function_ invoke__">cmp</span>(&amp;secret_number) &#123;</span><br><span class="line">            Ordering::Greater =&gt;<span class="built_in">println!</span>(<span class="string">&quot;Too big!&quot;</span>),</span><br><span class="line">            Ordering::Less =&gt;<span class="built_in">println!</span>(<span class="string">&quot;Too low!&quot;</span>),</span><br><span class="line">            Ordering::Equal =&gt;&#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">&quot;You win!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我的代码可能和官方稍有不同，因为我使用了更高版本的rand crate。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[package]</span><br><span class="line">name = &quot;guess_game&quot;</span><br><span class="line">version = &quot;0.1.0&quot;</span><br><span class="line">edition = &quot;2024&quot;</span><br><span class="line"></span><br><span class="line">[dependencies]</span><br><span class="line">rand = &quot;0.9.2&quot;</span><br></pre></td></tr></table></figure><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>在本节中我们先大概了解这些内容，初步对rust语言有个了解，在后续的课程中会对里面的一些知识点详细讲解。</p><h3 id="标准库和-crate"><a href="#标准库和-crate" class="headerlink" title="标准库和 crate"></a>标准库和 crate</h3><ul><li>rust 使用 <code>use</code> 引入标准库中的模块，例如 <code>std::cmp::Ordering</code> 用于比较两个值的大小关系，<code>std::io</code> 用于处理标准输入输出，<code>rand::Rng</code> 用于生成随机数。</li><li>std 为标准库的缩写，用于访问标准库中的函数和类型。</li><li>rand 是一个 crate（包），用于生成随机数。rand是一个非标准库，需要在 <code>Cargo.toml</code> 中添加依赖。使用cargo add rand 可以添加rand crate。或者在 <code>Cargo.toml</code> 中手动添加依赖。</li><li>crates.io 是一个 Rust 社区维护的 crate 仓库，用户可以在其中查找和分享 Rust 代码。</li></ul><h3 id="变量和可变性"><a href="#变量和可变性" class="headerlink" title="变量和可变性"></a>变量和可变性</h3><ul><li>rust 中的变量默认是不可变的，即一旦绑定了一个值，就不能改变它。例如 <code>let x = 5;</code> 绑定了一个值为5的变量x，之后不能再将x绑定到其他值。</li><li>如果需要一个可变的变量，需要使用 <code>mut</code> 关键字。例如 <code>let mut x = 5;</code> 绑定了一个可变的变量x，之后可以将x绑定到其他值。</li><li>变量的类型可以在声明时指定，也可以根据赋值的类型自动推断。例如 <code>let x = 5;</code> 中，x的类型被推断为 <code>i32</code>。</li><li>当然rust也有const关键字，用于定义常量，例如 <code>const X: i32 = 5;</code> 定义了一个值为5的常量X，之后不能再改变它。</li></ul><p>变量默认是不可变的，这是rust的一个设计原则，他可以帮助我们避免一些错误。主要作用是用在这种情况：</p><ul><li><strong>当我们定义的一个变量后面需要改变数据类型的时候，比如一开始用户输入的数字是一个字符串，但是后面和随机数进行比较我们需要将字符串转换为整数。</strong></li></ul><h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2><ul><li>生成新的字符串s可以使用 <code>let s = String::new();</code> </li><li>::new 那一行的 :: 语法表明 new 是 String 类型的一个 关联函数（associated function）。关联函数是针对某个类型实现的函数，在这个例子中是 String。</li><li>代码中的 .read_line(&amp;mut guess) 方法，用来获取用户输入。 将  <code>&amp;mut guess</code> 作为参数传递给 read_line 函数，让其将用户输入储存到这个字符串中。</li><li>read_line 的工作是，无论用户在标准输入中键入什么内容，都将其追加（不会覆盖其原有内容）到一个字符串中，<strong>因此它需要字符串作为参数</strong>。<strong>这个字符串参数应该是可变的</strong>，以便 read_line 将用户输入附加上去。</li><li><code>&amp;</code> 表示这个参数是一个 引用（reference），它允许多处代码访问同一处数据，而无需在内存中多次拷贝。</li></ul>]]></content:encoded>
      
      
      <category domain="https://sharpmind.tech/categories/Rust%E6%95%99%E7%A8%8B/">Rust教程</category>
      
      
      <category domain="https://sharpmind.tech/tags/Rust/">Rust</category>
      
      <category domain="https://sharpmind.tech/tags/%E7%8C%9C%E6%95%B0%E6%B8%B8%E6%88%8F/">猜数游戏</category>
      
      
    </item>
    
    <item>
      <title>hello rust 和cargo包管理器</title>
      <link>https://sharpmind.tech/rust/hello-rust-%E5%92%8Ccargo%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</link>
      <guid>https://sharpmind.tech/rust/hello-rust-%E5%92%8Ccargo%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</guid>
      <pubDate>Sat, 20 Dec 2025 03:36:50 GMT</pubDate>
      
      <description>本文介绍如何使用Rust编写第一个Hello World程序，以及Cargo包管理器的基本使用方法，包括项目创建、编译和运行。</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="打印一个hello-world"><a href="#打印一个hello-world" class="headerlink" title="打印一个hello world"></a>打印一个hello world</h2><p>创建一个rust项目，<code>mkdir my_project &amp;&amp; cd my_project</code></p><p>编写main.rs文件，<code>touch main.rs</code></p><p>在rust中，打印一个hello world非常简单，只需要在<code>main.rs</code>文件中添加以下代码即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们需要对main.rs文件进行 <strong>编译</strong>，执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustc main.rs</span><br></pre></td></tr></table></figure><p>这将编译项目并生成可执行文件。</p><p>执行以下命令 <strong>运行</strong> 项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main</span><br></pre></td></tr></table></figure><p>这将输出<code>hello world</code>。</p><p>编译和运行是彼此独立的步骤。</p><h2 id="使用cargo包管理器"><a href="#使用cargo包管理器" class="headerlink" title="使用cargo包管理器"></a>使用cargo包管理器</h2><p>虽然我们可以使用<code>rustc</code>来编译项目，但是使用<code>cargo</code>包管理器可以更方便地管理项目依赖和构建过程。</p><p>Cargo 是 Rust 的构建系统和包管理器。大多数 Rustacean 们使用 Cargo 来管理他们的 Rust 项目，因为它可以为你处理很多任务，比如构建代码、下载依赖库并编译这些库。（我们把代码所需要的库叫做 依赖（dependencies））。</p><p>安装了Rust后，Cargo 也会被安装。你可以通过在终端中运行 <code>cargo --version</code> 来检查是否安装了 Cargo。</p><h3 id="初始化一个cargo项目"><a href="#初始化一个cargo项目" class="headerlink" title="初始化一个cargo项目"></a>初始化一个cargo项目</h3><p>执行以下命令初始化一个cargo项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new hello_cargo</span><br></pre></td></tr></table></figure><p>这将在当前目录创建一个新的cargo项目，包含一个<code>Cargo.toml</code>文件和一个<code>src/main.rs</code>文件。</p><p>Cargo.toml文件是cargo项目的配置文件，它包含了项目的元数据和依赖信息。</p><p>以下是一个简单的Cargo.toml文件示例：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;hello_cargo&quot;</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">&quot;0.1.0&quot;</span></span><br><span class="line"><span class="attr">edition</span> = <span class="string">&quot;2024&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span>  </span><br></pre></td></tr></table></figure><p>这个文件使用 TOML (Tom’s Obvious, Minimal Language) 格式，这是 Cargo 配置文件的格式。</p><p>第一行，[package]，是一个片段 section 标题，表明下面的语句用来配置一个包。随着我们在这个文件增加更多的信息，还将增加其他 section。</p><p>接下来的三行设置了 Cargo 编译程序所需的配置：项目的名称、项目的版本以及要使用的 Rust 版本。附录 E 会介绍 edition 的值。</p><p>最后一行，[dependencies]，是罗列项目依赖的 section 的开始。在 Rust 中，代码包被称为 crates。这个项目并不需要其他的 crate，不过在第二章的第一个项目会用到依赖，那时会用得上这个 section。</p><h3 id="cargo-build"><a href="#cargo-build" class="headerlink" title="cargo build"></a>cargo build</h3><p>执行以下命令编译项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo build</span><br></pre></td></tr></table></figure><p>这个命令会创建一个可执行文件 target&#x2F;debug&#x2F;hello_cargo （在 Windows 上是 target\debug\hello_cargo.exe），而不是放在目前目录下。由于默认的构建方法是调试构建（debug build），Cargo 会将可执行文件放在名为 debug 的目录中。可以通过这个命令运行可执行文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./target/debug/hello_cargo <span class="comment"># 或者在 Windows 下为 .\target\debug\hello_cargo.exe</span></span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure><p>如果一切顺利，终端上应该会打印出 Hello, world!。</p><h3 id="cargo-run"><a href="#cargo-run" class="headerlink" title="cargo run"></a>cargo run</h3><p>cargo build 需要进入到项目目录下执行。这样操作起来还是比较麻烦的。</p><p>cargo run 命令会自动编译项目并运行可执行文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo run</span><br></pre></td></tr></table></figure><p>这将编译项目并运行可执行文件。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了如何使用Rust编写第一个Hello World程序，以及Cargo包管理器的基本使用方法，包括项目创建、编译和运行。</p><p>更详细的解释可以参考<a href="https://doc.rust-lang.org/book/ch01-02-hello-world.html">Rust官方文档 hello world</a></p><p>非官方中文文档: <a href="https://kaisery.github.io/trpl-zh-cn/ch01-03-hello-cargo.html">Rust中文文档 hello cargo</a></p>]]></content:encoded>
      
      
      <category domain="https://sharpmind.tech/categories/Rust%E6%95%99%E7%A8%8B/">Rust教程</category>
      
      
      <category domain="https://sharpmind.tech/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</category>
      
      <category domain="https://sharpmind.tech/tags/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/">入门教程</category>
      
      <category domain="https://sharpmind.tech/tags/rust/">rust</category>
      
      <category domain="https://sharpmind.tech/tags/cargo/">cargo</category>
      
      
    </item>
    
    <item>
      <title>Git子模块初始化问题解决与主动更新策略</title>
      <link>https://sharpmind.tech/Git%E5%AD%90%E6%A8%A1%E5%9D%97%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E4%B8%8E%E4%B8%BB%E5%8A%A8%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5/</link>
      <guid>https://sharpmind.tech/Git%E5%AD%90%E6%A8%A1%E5%9D%97%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E4%B8%8E%E4%B8%BB%E5%8A%A8%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5/</guid>
      <pubDate>Fri, 19 Dec 2025 12:43:00 GMT</pubDate>
      
      <description>详细记录Git子模块初始化问题的完整解决方案，以及如何实现主动控制的子模块更新策略，避免自动更新带来的意外问题。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="Git子模块初始化问题解决与主动更新策略"><a href="#Git子模块初始化问题解决与主动更新策略" class="headerlink" title="Git子模块初始化问题解决与主动更新策略"></a>Git子模块初始化问题解决与主动更新策略</h1><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>在使用Hexo博客框架配合Butterfly主题时，经常会遇到Git子模块的配置问题。最近遇到的一个典型问题是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git submodule status</span><br><span class="line">-1fe36a26c2f7da173c4bfbdab849bf8cd686f648 themes/butterfly</span><br></pre></td></tr></table></figure><p><strong>关键问题特征：</strong></p><ul><li>子模块状态显示为 <code>-1fe36a26...</code></li><li>前面的 <code>-</code> 符号表示子模块未正确初始化</li><li>虽然子模块目录存在，但Git无法正确识别其状态</li></ul><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="1-子模块初始化状态"><a href="#1-子模块初始化状态" class="headerlink" title="1. 子模块初始化状态"></a>1. 子模块初始化状态</h3><p>Git子模块的状态显示格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[状态前缀][提交哈希] [子模块路径] [(版本标签)]</span><br></pre></td></tr></table></figure><p><strong>状态前缀含义：</strong></p><ul><li><strong><code>-</code></strong> - 子模块未初始化（最常见的问题）</li><li><strong><code>+</code></strong> - 子模块有未提交的更改</li><li><strong><code>U</code></strong> - 子模块有冲突需要解决</li><li><strong>无前缀</strong> - 子模块状态正常</li></ul><h3 id="2-问题根源"><a href="#2-问题根源" class="headerlink" title="2. 问题根源"></a>2. 问题根源</h3><p>通过检查发现，问题通常出现在以下几个方面：</p><ol><li><p><strong>子模块目录存在但配置不完整</strong></p><ul><li><code>themes/butterfly/.git</code> 目录存在</li><li>但主项目的Git配置中缺少正确的子模块映射</li></ul></li><li><p><strong>Git配置中的 <code>update = none</code></strong></p><ul><li>在 <code>.git/config</code> 中发现子模块配置为 <code>update = none</code></li><li>这阻止了子模块的自动更新，但也可能导致初始化问题</li></ul></li><li><p><strong>子模块迁移过程中的问题</strong></p><ul><li>Git尝试将子模块的 <code>.git</code> 目录迁移到主项目的模块目录</li><li>迁移过程中可能出现配置不一致</li></ul></li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="完整修复步骤"><a href="#完整修复步骤" class="headerlink" title="完整修复步骤"></a>完整修复步骤</h3><h4 id="步骤1：清理现有子模块配置"><a href="#步骤1：清理现有子模块配置" class="headerlink" title="步骤1：清理现有子模块配置"></a>步骤1：清理现有子模块配置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 强制清理子模块配置</span></span><br><span class="line">git submodule deinit -f themes/butterfly</span><br></pre></td></tr></table></figure><p><strong>命令说明：</strong></p><ul><li><code>deinit</code> - 取消子模块的初始化</li><li><code>-f</code> - 强制清理，即使有未提交的更改</li><li>这个命令会将子模块的Git配置迁移到主项目的模块目录</li></ul><h4 id="步骤2：重新初始化子模块"><a href="#步骤2：重新初始化子模块" class="headerlink" title="步骤2：重新初始化子模块"></a>步骤2：重新初始化子模块</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新初始化子模块</span></span><br><span class="line">git submodule update --init themes/butterfly</span><br></pre></td></tr></table></figure><p><strong>命令说明：</strong></p><ul><li><code>update --init</code> - 更新并初始化指定的子模块</li><li>这个命令会读取 <code>.gitmodules</code> 文件中的配置</li><li>检出子模块到正确的提交版本</li></ul><h4 id="步骤3：验证修复结果"><a href="#步骤3：验证修复结果" class="headerlink" title="步骤3：验证修复结果"></a>步骤3：验证修复结果</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查子模块状态</span></span><br><span class="line">git submodule status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预期输出：</span></span><br><span class="line"><span class="comment"># 1fe36a26c2f7da173c4bfbdab849bf8cd686f648 themes/butterfly (5.5.3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查子模块的.git文件</span></span><br><span class="line"><span class="built_in">ls</span> -la themes/butterfly/.git</span><br><span class="line"><span class="comment"># 应该显示为一个文件，而不是目录</span></span><br></pre></td></tr></table></figure><h3 id="验证修复成功的标志"><a href="#验证修复成功的标志" class="headerlink" title="验证修复成功的标志"></a>验证修复成功的标志</h3><ol><li><strong>状态前缀消失</strong>：<code>-</code> 符号不再显示</li><li><strong>版本标签显示</strong>：显示具体的版本号 <code>(5.5.3)</code></li><li><strong>.git文件正确</strong>：子模块目录下的 <code>.git</code> 应该是一个文件</li></ol><h2 id="主动更新策略"><a href="#主动更新策略" class="headerlink" title="主动更新策略"></a>主动更新策略</h2><h3 id="为什么需要主动更新？"><a href="#为什么需要主动更新？" class="headerlink" title="为什么需要主动更新？"></a>为什么需要主动更新？</h3><p>在项目开发中，我们通常不希望子模块自动更新，因为：</p><ol><li><strong>版本稳定性</strong>：自动更新可能引入不兼容的更改</li><li><strong>可控性</strong>：需要测试新版本后再决定是否更新</li><li><strong>团队协作</strong>：确保所有团队成员使用相同的子模块版本</li></ol><h3 id="配置子模块不自动更新"><a href="#配置子模块不自动更新" class="headerlink" title="配置子模块不自动更新"></a>配置子模块不自动更新</h3><p>在 <code>.git/config</code> 文件中配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[submodule &quot;themes/butterfly&quot;]</span></span><br><span class="line">    <span class="attr">update</span> = none</span><br></pre></td></tr></table></figure><p>或者在克隆项目时指定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recurse-submodules --shallow-submodules &lt;repository&gt;</span><br></pre></td></tr></table></figure><h3 id="主动更新子模块的几种方式"><a href="#主动更新子模块的几种方式" class="headerlink" title="主动更新子模块的几种方式"></a>主动更新子模块的几种方式</h3><h4 id="方式1：更新到最新版本"><a href="#方式1：更新到最新版本" class="headerlink" title="方式1：更新到最新版本"></a>方式1：更新到最新版本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新子模块到远程仓库的最新提交</span></span><br><span class="line">git submodule update --remote themes/butterfly</span><br></pre></td></tr></table></figure><p><strong>适用场景：</strong></p><ul><li>需要获取最新的功能或修复</li><li>不关心具体的版本号</li></ul><h4 id="方式2：更新到特定版本"><a href="#方式2：更新到特定版本" class="headerlink" title="方式2：更新到特定版本"></a>方式2：更新到特定版本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入子模块目录</span></span><br><span class="line"><span class="built_in">cd</span> themes/butterfly</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看可用的版本标签</span></span><br><span class="line">git tag -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到特定版本</span></span><br><span class="line">git checkout v5.5.4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回主项目目录</span></span><br><span class="line"><span class="built_in">cd</span> ../..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交子模块版本更新</span></span><br><span class="line">git add themes/butterfly</span><br><span class="line">git commit -m <span class="string">&quot;更新Butterfly主题到v5.5.4版本&quot;</span></span><br></pre></td></tr></table></figure><p><strong>适用场景：</strong></p><ul><li>需要特定的稳定版本</li><li>版本间有重大变更需要测试</li></ul><h4 id="方式3：批量更新所有子模块"><a href="#方式3：批量更新所有子模块" class="headerlink" title="方式3：批量更新所有子模块"></a>方式3：批量更新所有子模块</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新所有子模块到最新版本</span></span><br><span class="line">git submodule update --remote</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者更新所有子模块到配置的版本</span></span><br><span class="line">git submodule update --recursive</span><br></pre></td></tr></table></figure><h3 id="更新策略建议"><a href="#更新策略建议" class="headerlink" title="更新策略建议"></a>更新策略建议</h3><ol><li><strong>开发环境</strong>：可以配置为自动更新，及时获取最新功能</li><li><strong>生产环境</strong>：建议使用手动更新，确保版本稳定性</li><li><strong>团队项目</strong>：统一子模块版本，避免兼容性问题</li></ol><h2 id="常见问题排查"><a href="#常见问题排查" class="headerlink" title="常见问题排查"></a>常见问题排查</h2><h3 id="问题1：子模块状态显示-前缀"><a href="#问题1：子模块状态显示-前缀" class="headerlink" title="问题1：子模块状态显示 + 前缀"></a>问题1：子模块状态显示 <code>+</code> 前缀</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+1fe36a26c2f7da173c4bfbdab849bf8cd686f648 themes/butterfly</span><br></pre></td></tr></table></figure><p><strong>解决方案：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入子模块提交更改</span></span><br><span class="line"><span class="built_in">cd</span> themes/butterfly</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;提交子模块更改&quot;</span></span><br><span class="line"><span class="built_in">cd</span> ../..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在主项目中提交子模块引用更新</span></span><br><span class="line">git add themes/butterfly</span><br><span class="line">git commit -m <span class="string">&quot;更新子模块引用&quot;</span></span><br></pre></td></tr></table></figure><h3 id="问题2：子模块状态显示-U-前缀"><a href="#问题2：子模块状态显示-U-前缀" class="headerlink" title="问题2：子模块状态显示 U 前缀"></a>问题2：子模块状态显示 <code>U</code> 前缀</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">U1fe36a26c2f7da173c4bfbdab849bf8cd686f648 themes/butterfly</span><br></pre></td></tr></table></figure><p><strong>解决方案：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入子模块解决冲突</span></span><br><span class="line"><span class="built_in">cd</span> themes/butterfly</span><br><span class="line">git status  <span class="comment"># 查看冲突文件</span></span><br><span class="line">git diff    <span class="comment"># 查看具体冲突</span></span><br><span class="line"><span class="comment"># 手动解决冲突后</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;解决子模块冲突&quot;</span></span><br><span class="line"><span class="built_in">cd</span> ../..</span><br></pre></td></tr></table></figure><h3 id="问题3：子模块目录为空"><a href="#问题3：子模块目录为空" class="headerlink" title="问题3：子模块目录为空"></a>问题3：子模块目录为空</h3><p><strong>解决方案：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新初始化和更新所有子模块</span></span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ol><li><strong>定期检查子模块状态</strong>：<code>git submodule status</code></li><li><strong>提交前验证子模块</strong>：确保子模块引用正确</li><li><strong>使用版本标签</strong>：而不是直接使用提交哈希</li><li><strong>文档记录</strong>：在README中记录子模块的更新策略</li><li><strong>团队沟通</strong>：子模块更新前与团队成员沟通</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Git子模块是管理项目依赖的强大工具，但需要正确的配置和维护。通过本文介绍的解决方案和主动更新策略，您可以：</p><ul><li>快速解决子模块初始化问题</li><li>实现可控的子模块版本管理</li><li>避免自动更新带来的意外问题</li><li>确保项目的稳定性和可维护性</li></ul><p>子模块管理的核心是<strong>可控性</strong>和<strong>可预测性</strong>，主动更新策略让您完全掌握依赖版本的变化。</p>]]></content:encoded>
      
      
      <category domain="https://sharpmind.tech/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/">技术笔记</category>
      
      
      <category domain="https://sharpmind.tech/tags/Git/">Git</category>
      
      <category domain="https://sharpmind.tech/tags/Hexo/">Hexo</category>
      
      <category domain="https://sharpmind.tech/tags/Butterfly%E4%B8%BB%E9%A2%98/">Butterfly主题</category>
      
      <category domain="https://sharpmind.tech/tags/git%E5%AD%90%E6%A8%A1%E5%9D%97/">git子模块</category>
      
      <category domain="https://sharpmind.tech/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/">版本控制</category>
      
      
      <comments>https://sharpmind.tech/Git%E5%AD%90%E6%A8%A1%E5%9D%97%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E4%B8%8E%E4%B8%BB%E5%8A%A8%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Git子模块配置问题解决：Hexo Butterfly主题未提交内容问题</title>
      <link>https://sharpmind.tech/Git%E5%AD%90%E6%A8%A1%E5%9D%97%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</link>
      <guid>https://sharpmind.tech/Git%E5%AD%90%E6%A8%A1%E5%9D%97%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</guid>
      <pubDate>Fri, 19 Dec 2025 12:16:00 GMT</pubDate>
      
      <description>详细记录在Hexo博客中使用Butterfly主题时遇到的Git子模块配置问题及完整解决方案，包括问题分析、解决步骤和技术原理说明。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="Git子模块配置问题解决：Hexo-Butterfly主题未提交内容问题"><a href="#Git子模块配置问题解决：Hexo-Butterfly主题未提交内容问题" class="headerlink" title="Git子模块配置问题解决：Hexo Butterfly主题未提交内容问题"></a>Git子模块配置问题解决：Hexo Butterfly主题未提交内容问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在使用Hexo框架搭建博客时，通过Git命令安装了Butterfly主题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure><p>之后运行 <code>git status</code> 时发现Git显示有未提交的内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">        modified:   themes/butterfly (new commits)</span><br></pre></td></tr></table></figure><p>但实际检查 <code>themes/butterfly</code> 目录时，Git状态显示工作区是干净的。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h3><p>问题出现在Git的子模块（submodule）配置上：</p><ol><li><p><strong>子模块标记存在但配置不完整</strong>：</p><ul><li>Git索引中将 <code>themes/butterfly</code> 标记为子模块（模式160000）</li><li>但缺少对应的 <code>.gitmodules</code> 文件配置</li></ul></li><li><p><strong>Git检测到不一致</strong>：</p><ul><li>Git认为子模块有新的提交需要处理</li><li>但由于缺少子模块映射配置，无法正确处理这些更改</li></ul></li></ol><h3 id="验证问题"><a href="#验证问题" class="headerlink" title="验证问题"></a>验证问题</h3><p>通过以下命令可以确认问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查Git文件状态</span></span><br><span class="line">git ls-files --stage | grep butterfly</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果：</span></span><br><span class="line"><span class="comment"># 160000 d369de91b8f32df02540f637659fed9abc9aa50e 0       themes/butterfly</span></span><br></pre></td></tr></table></figure><p>模式 <code>160000</code> 确认这是一个Git子模块引用。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="方案选择"><a href="#方案选择" class="headerlink" title="方案选择"></a>方案选择</h3><p>由于Butterfly主题是通过 <code>git clone</code> 安装的，正确的做法是将其配置为Git子模块，而不是普通目录。</p><h3 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h3><h4 id="步骤1：检查现有配置"><a href="#步骤1：检查现有配置" class="headerlink" title="步骤1：检查现有配置"></a>步骤1：检查现有配置</h4><p>首先检查是否已存在子模块配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查.gitmodules文件</span></span><br><span class="line"><span class="built_in">cat</span> .gitmodules</span><br></pre></td></tr></table></figure><p>如果文件存在但未提交，说明配置已存在但需要完善。</p><h4 id="步骤2：重新初始化子模块"><a href="#步骤2：重新初始化子模块" class="headerlink" title="步骤2：重新初始化子模块"></a>步骤2：重新初始化子模块</h4><p>使用Git子模块更新命令重新初始化：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure><p>这个命令会：</p><ul><li>读取 <code>.gitmodules</code> 文件中的配置</li><li>初始化所有子模块</li><li>检出子模块的正确提交版本</li></ul><h4 id="步骤3：提交修复"><a href="#步骤3：提交修复" class="headerlink" title="步骤3：提交修复"></a>步骤3：提交修复</h4><p>重新初始化后，Git状态会显示需要提交的更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出示例：</span></span><br><span class="line"><span class="comment"># Changes to be committed:</span></span><br><span class="line"><span class="comment">#   new file:   .gitmodules</span></span><br><span class="line"><span class="comment">#   modified:   themes/butterfly</span></span><br></pre></td></tr></table></figure><p>提交这些更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;修复: 正确配置butterfly主题子模块</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- 添加.gitmodules文件配置子模块</span></span><br><span class="line"><span class="string">- 更新themes/butterfly子模块引用&quot;</span></span><br></pre></td></tr></table></figure><h2 id="完整的解决命令序列"><a href="#完整的解决命令序列" class="headerlink" title="完整的解决命令序列"></a>完整的解决命令序列</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 检查当前状态</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 重新初始化子模块</span></span><br><span class="line">git submodule update --init --recursive</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 再次检查状态</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 提交修复</span></span><br><span class="line">git commit -m <span class="string">&quot;修复: 正确配置butterfly主题子模块&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 确认问题已解决</span></span><br><span class="line">git status</span><br></pre></td></tr></table></figure><h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><h3 id="Git子模块的工作原理"><a href="#Git子模块的工作原理" class="headerlink" title="Git子模块的工作原理"></a>Git子模块的工作原理</h3><p>Git子模块允许在一个Git仓库中包含另一个Git仓库：</p><ol><li><strong><code>.gitmodules</code> 文件</strong>：存储子模块的配置信息</li><li><strong>子模块引用</strong>：主仓库记录子模块的特定提交版本</li><li><strong>独立管理</strong>：子模块可以独立更新和提交</li></ol><h3 id="为什么选择子模块方案"><a href="#为什么选择子模块方案" class="headerlink" title="为什么选择子模块方案"></a>为什么选择子模块方案</h3><p>对于Hexo主题管理，使用子模块有以下优势：</p><ol><li><strong>版本控制</strong>：可以锁定主题的特定版本</li><li><strong>独立更新</strong>：主题可以独立于主项目进行更新</li><li><strong>协作友好</strong>：其他开发者克隆项目时会自动获取正确版本的主题</li><li><strong>干净分离</strong>：主题的Git历史与主项目分离</li></ol><h2 id="预防措施"><a href="#预防措施" class="headerlink" title="预防措施"></a>预防措施</h2><h3 id="正确的主题安装方式"><a href="#正确的主题安装方式" class="headerlink" title="正确的主题安装方式"></a>正确的主题安装方式</h3><p>为了避免类似问题，建议使用以下方式安装Hexo主题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方式1：作为子模块安装（推荐）</span></span><br><span class="line">git submodule add https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2：如果已通过git clone安装，及时提交子模块配置</span></span><br><span class="line">git add .gitmodules themes/butterfly</span><br><span class="line">git commit -m <span class="string">&quot;添加butterfly主题子模块&quot;</span></span><br></pre></td></tr></table></figure><h3 id="日常维护建议"><a href="#日常维护建议" class="headerlink" title="日常维护建议"></a>日常维护建议</h3><ol><li><strong>更新主题</strong>：在子模块目录中独立进行更新</li><li><strong>提交主题更改</strong>：在主项目中提交子模块的版本更新</li><li><strong>协作注意事项</strong>：提醒协作者使用 <code>git submodule update --init</code> 初始化子模块</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次问题是由于Git子模块配置不完整导致的。通过重新初始化子模块并提交正确的配置，成功解决了”未提交内容”的假阳性问题。</p><p><strong>关键要点</strong>：</p><ul><li>Git子模块是管理依赖项目的有效方式</li><li>完整的子模块配置需要 <code>.gitmodules</code> 文件和正确的子模块引用</li><li>定期维护子模块配置可以避免类似问题</li></ul><p>这种解决方案不仅解决了当前问题，还为项目的长期维护提供了更好的结构。</p>]]></content:encoded>
      
      
      <category domain="https://sharpmind.tech/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/">技术笔记</category>
      
      
      <category domain="https://sharpmind.tech/tags/Git/">Git</category>
      
      <category domain="https://sharpmind.tech/tags/Hexo/">Hexo</category>
      
      <category domain="https://sharpmind.tech/tags/Butterfly%E4%B8%BB%E9%A2%98/">Butterfly主题</category>
      
      <category domain="https://sharpmind.tech/tags/git%E5%AD%90%E6%A8%A1%E5%9D%97/">git子模块</category>
      
      <category domain="https://sharpmind.tech/tags/git%E7%AE%A1%E7%90%86/">git管理</category>
      
      
      <comments>https://sharpmind.tech/Git%E5%AD%90%E6%A8%A1%E5%9D%97%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Rust 入门教程说明</title>
      <link>https://sharpmind.tech/rust/Rust%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E8%AF%B4%E6%98%8E/</link>
      <guid>https://sharpmind.tech/rust/Rust%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E8%AF%B4%E6%98%8E/</guid>
      <pubDate>Fri, 19 Dec 2025 02:00:00 GMT</pubDate>
      
      <description>Rust 是一种现代系统编程语言，具有内存安全、高性能和并发特性。本文介绍 Rust 的基本概念和入门知识。</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>本教程是 Rust 编程语言的入门教程，基于官方书籍&#x2F;文档<a href="https://doc.rust-lang.org/book/">《The Rust Programming Language》</a>。</p><p>目前使用的是最新教程2024版本。</p><blockquote><p>This version of the text assumes you’re using Rust 1.85.0 (released 2025-02-17) or later with <code>edition = &quot;2024&quot;</code> in the <em>Cargo.toml</em> file of all projects to configure them to use Rust 2024 Edition idioms. See the <a href="https://doc.rust-lang.org/book/ch01-01-installation.html">“Installation” section of Chapter 1</a> for instructions on installing or updating Rust, and see <a href="https://doc.rust-lang.org/book/appendix-05-editions.html">Appendix E</a> for information on editions.</p></blockquote><p>大家也可以参考B站杨旭老师的 <a href="https://www.bilibili.com/video/BV1mhxNe7E1g">Rust 编程语言教程合集</a>，目前是2021版。需要注意的是，本教程基于2024版本，与杨旭老师的视频可能会有差异。</p><h2 id="明确学习目标"><a href="#明确学习目标" class="headerlink" title="明确学习目标"></a>明确学习目标</h2><p><img src="https://cdn.sanity.io/images/1y08pmef/production/3e748df252093a56ffc237df6fbea0292445f090-1688x384.png" alt="知止而后有定，定而后能静，静而后能安，安而后能虑，虑而后能得。物有本末，事有终始。知所先后，则近道矣。---《礼记·大学》"></p><h2 id="为什么选择Rust"><a href="#为什么选择Rust" class="headerlink" title="为什么选择Rust"></a>为什么选择Rust</h2><p>Rust 是一种系统编程语言，由 Mozilla 开发，具有以下特点：</p><p>Rust 可以编写高性能的系统级应用程序，同时保持内存安全和线程安全。</p><ul><li>内存安全，且不牺牲性能</li><li>编译通过就能正常运行</li><li>优秀且不断发展的生态系统</li><li>用途广泛，包括但不限于：<ul><li>系统级应用程序</li><li>游戏开发</li><li>网络编程</li><li>嵌入式系统</li></ul></li><li>提供现代开发工具，如：<ul><li>包管理器（cargo）</li><li>代码格式化工具（rustfmt）</li><li>代码分析工具（rust-analyzer）</li><li>RustRover （JetBrains 公司开发的 Rust 集成开发环境）</li></ul></li></ul><h2 id="Rust语言发展历史"><a href="#Rust语言发展历史" class="headerlink" title="Rust语言发展历史"></a>Rust语言发展历史</h2><ul><li>2006年：Graydon Hoare开始设计Rust（个人项目）。</li><li>2009年：Mozilla开始关注Rust，希望它能成为一种更安全的系统编程语言。</li><li>2010年：Mozilla正式支持Rust项目。</li><li>2012年：Rust的第一个编译器（rustc）实现了自举（即用Rust编写的编译器可以编译自己）。</li><li>2014年：Rust 0.9版本发布，从此Rust开始逐渐稳定。</li><li><strong>2015年：Rust 1.0正式发布，稳定版本的Rust开始对外提供支持。</strong></li><li>2016年：Rust开始获得广泛关注，社区逐渐壮大。</li><li>2018年：WebAssembly的推广使得Rust成为一个受欢迎的前端编程语言。</li><li>2021年：Rust基金会成立，负责管理和发展Rust项目。Rust2021发布。</li><li>2022年：Rust被用于Linux内核开发，成为了一种重要的系统编程语言。</li><li>2025年：Rust 2024 Edition 发布，引入了更多的语言特性和改进。</li></ul><h2 id="安装Rust"><a href="#安装Rust" class="headerlink" title="安装Rust"></a>安装Rust</h2><p>安装技能属于程序员的基操了 ，这里就不展开讲了。大家按照官方地址安装即可。</p><p>官方网站安装地址: <a href="https://rust-lang.org/zh-CN/">https://rust-lang.org/zh-CN/</a></p><p>官方Docs命令行安装地址: <a href="https://doc.rust-lang.org/book/ch01-01-installation.html">https://doc.rust-lang.org/book/ch01-01-installation.html</a></p><h3 id="参考视频"><a href="#参考视频" class="headerlink" title="参考视频"></a>参考视频</h3><div class="bilibili-video"><iframe src="//player.bilibili.com/player.html?isOutside=true&aid=113218290717948&bvid=BV1yBxze6Epo&cid=26053837081&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe></div><style>.bilibili-video {    max-width: 800px;    margin: 20px auto;}.bilibili-video iframe {    width: 100%;    height: 450px;    border: none;}/* 平板设备 */@media (max-width: 1024px) {    .bilibili-video iframe {        height: 400px;    }}/* 手机设备 */@media (max-width: 768px) {    .bilibili-video {        margin: 15px 10px;    }        .bilibili-video iframe {        height: 300px;    }}/* 小屏手机 */@media (max-width: 480px) {    .bilibili-video {        margin: 10px 5px;    }        .bilibili-video iframe {        height: 250px;    }}</style><h2 id="安装确认"><a href="#安装确认" class="headerlink" title="安装确认"></a>安装确认</h2><p>注意：安装后需要重新启动一下终端工具，才能生效。</p><ul><li>确认是否安装查看版本 <code>rustc --version</code></li><li>升级命令 <code>rustup  update</code></li><li>卸载命令 <code>rustup self uninstall</code></li></ul><h2 id="安装RustRouver-以及rust-analyze-VSCode"><a href="#安装RustRouver-以及rust-analyze-VSCode" class="headerlink" title="安装RustRouver 以及rust-analyze(VSCode)"></a>安装RustRouver 以及rust-analyze(VSCode)</h2><p>RustRouver 是 JetBrains 公司开发的 Rust 集成开发环境，提供了丰富的功能，如代码补全、语法高亮、代码导航等。</p><ul><li><a href="https://www.jetbrains.com/rust/">官方地址英文</a></li><li><a href="https://www.jetbrains.com/zh-cn/rust/">官方地址中文</a></li></ul><p>rust-analyze 是 Rust 官方提供的代码分析工具，用于检查 Rust 代码中的错误和警告。</p><p>大家可以根据自己的操作系统，选择对应的安装方式。</p>]]></content:encoded>
      
      
      <category domain="https://sharpmind.tech/categories/Rust%E6%95%99%E7%A8%8B/">Rust教程</category>
      
      
      <category domain="https://sharpmind.tech/tags/Rust/">Rust</category>
      
      <category domain="https://sharpmind.tech/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</category>
      
      <category domain="https://sharpmind.tech/tags/%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/">入门教程</category>
      
      
      <comments>https://sharpmind.tech/rust/Rust%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E8%AF%B4%E6%98%8E/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Ubuntu24服务器安装Docker时报错：curl (35) Recv failure: Connection reset by peer</title>
      <link>https://sharpmind.tech/Ubuntu24%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85Docker%E6%97%B6%E6%8A%A5%E9%94%99%EF%BC%9Acurl-35-Recv-failure-Connection-reset-by-peer/</link>
      <guid>https://sharpmind.tech/Ubuntu24%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85Docker%E6%97%B6%E6%8A%A5%E9%94%99%EF%BC%9Acurl-35-Recv-failure-Connection-reset-by-peer/</guid>
      <pubDate>Sun, 19 Oct 2025 15:10:04 GMT</pubDate>
      
      <description>记录在Ubuntu云服务器上安装Docker时出现curl (35) Recv failure: Connection reset by peer的原因与解决办法。</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="🧩-问题背景"><a href="#🧩-问题背景" class="headerlink" title="🧩 问题背景"></a>🧩 问题背景</h2><p>按照<a href="https://docs.docker.com/engine/install/ubuntu/">Docker官方文档</a>，在腾讯云 Ubuntu 24.04 服务器上安装 Docker 时,执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc</span><br></pre></td></tr></table></figure><p>结果出现错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl: (35) Recv failure: Connection reset by peer</span><br></pre></td></tr></table></figure><p>这个错误表示你的系统无法与 Docker 官方服务器成功建立 TLS（Transport Layer Security 可以粗略认为是 HTTPS）连接。</p><h2 id="🧩-检查网络与防火墙"><a href="#🧩-检查网络与防火墙" class="headerlink" title="🧩 检查网络与防火墙"></a>🧩 检查网络与防火墙</h2><p>执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping download.docker.com</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v https://download.docker.com/</span><br></pre></td></tr></table></figure><p>如果连接超时或被 reset，很可能是：</p><ul><li>云服务器（比如腾讯云）出站被防火墙或代理限制；</li><li>或所在网络（尤其是中国大陆）访问 Docker 官方源受阻。</li></ul><h2 id="解决方案一：使用国内镜像（推荐）"><a href="#解决方案一：使用国内镜像（推荐）" class="headerlink" title="解决方案一：使用国内镜像（推荐）"></a>解决方案一：使用国内镜像（推荐）</h2><p>使用国内镜像源，这是腾讯云提供的镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> curl -fsSL https://mirrors.cloud.tencent.com/docker-ce/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc</span><br></pre></td></tr></table></figure><p>参考<a href="https://cloud.tencent.com/document/product/213/46000#1H-kXbk9zoqvzYMVPVsBO">腾讯云服务安装docker</a></p><h2 id="解决方案二：让云服务器走代理（进阶）"><a href="#解决方案二：让云服务器走代理（进阶）" class="headerlink" title="解决方案二：让云服务器走代理（进阶）"></a>解决方案二：让云服务器走代理（进阶）</h2><p>如果你希望服务器访问外网都能通过代理，可在服务器上部署代理（如 Clash、v2ray、shadowsocks），并设置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> https_proxy=http://127.0.0.1:7890</span><br><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:7890</span><br></pre></td></tr></table></figure><p>然后重新执行 curl 命令。</p><h2 id="解决方案三：手动下载-GPG-文件上传到服务器"><a href="#解决方案三：手动下载-GPG-文件上传到服务器" class="headerlink" title="解决方案三：手动下载 GPG 文件上传到服务器"></a>解决方案三：手动下载 GPG 文件上传到服务器</h2><p>如果本地可以访问 Docker 官方源，也可以先下载好文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o docker.gpg</span><br><span class="line">scp docker.gpg ubuntu@&lt;服务器IP&gt;:/tmp/docker.gpg</span><br></pre></td></tr></table></figure><p>再在服务器执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> install -m 0755 -d /etc/apt/keyrings</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> /tmp/docker.gpg /etc/apt/keyrings/docker.gpg</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> a+r /etc/apt/keyrings/docker.gpg</span><br></pre></td></tr></table></figure><p>这样就可以继续后续安装流程。</p><p>安装完成后验证：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker --version</span><br><span class="line">docker compose version</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://sharpmind.tech/categories/Docker/">Docker</category>
      
      
      <category domain="https://sharpmind.tech/tags/Ubuntu/">Ubuntu</category>
      
      <category domain="https://sharpmind.tech/tags/Docker/">Docker</category>
      
      <category domain="https://sharpmind.tech/tags/%E8%85%BE%E8%AE%AF%E4%BA%91/">腾讯云</category>
      
      <category domain="https://sharpmind.tech/tags/%E9%95%9C%E5%83%8F%E6%BA%90/">镜像源</category>
      
      
    </item>
    
    <item>
      <title>免费简易截图设备模型生成网站总结</title>
      <link>https://sharpmind.tech/%E5%85%8D%E8%B4%B9%E7%AE%80%E6%98%93%E6%88%AA%E5%9B%BE%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B%E7%94%9F%E6%88%90%E7%BD%91%E7%AB%99%E6%80%BB%E7%BB%93/</link>
      <guid>https://sharpmind.tech/%E5%85%8D%E8%B4%B9%E7%AE%80%E6%98%93%E6%88%AA%E5%9B%BE%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B%E7%94%9F%E6%88%90%E7%BD%91%E7%AB%99%E6%80%BB%E7%BB%93/</guid>
      <pubDate>Wed, 10 Sep 2025 08:35:33 GMT</pubDate>
      
      <description>总结几个免费简易的截图设备模型生成网站，帮助设计师、开发者或内容创作者快速美化截图。</description>
      
      
      
      <content:encoded><![CDATA[<p>在做产品展示、写博客或者准备演示文档时，常常需要把软件界面、网页或代码截图美化，放到设备模型中或者加上背景效果。下面整理了几个<strong>免费简易的截图设备模型生成网站</strong>，无需安装软件，直接在线就能使用。</p><h2 id="Shotsnapp"><a href="#Shotsnapp" class="headerlink" title="Shotsnapp"></a>Shotsnapp</h2><p><a href="https://app.shotsnapp.com/">Shotsnapp</a></p><p>Shotsnapp 提供多种设备模型（手机、平板、笔记本等），用户只需要上传截图，就可以快速生成带有设备外框的效果图，适合做产品展示。支持背景修改和阴影效果，界面简洁易用。</p><h2 id="Mockuphone"><a href="#Mockuphone" class="headerlink" title="Mockuphone"></a>Mockuphone</h2><p><a href="https://mockuphone.com/">Mockuphone</a></p><p>Mockuphone 更偏向设备外观展示，提供了丰富的手机、平板、电脑甚至智能手表的模型。上传截图后，工具会自动生成设备展示效果，适合制作宣传素材和产品预览图。</p><h2 id="Screely"><a href="#Screely" class="headerlink" title="Screely"></a>Screely</h2><p><a href="https://screely.com/">Screely</a></p><p>Screely 专注于截图美化，特别适合快速给截图加上干净的背景和阴影。无需注册，直接上传即可生成美观的效果，非常适合写博客或做文档展示时使用。</p><h2 id="Screenzy"><a href="#Screenzy" class="headerlink" title="Screenzy"></a>Screenzy</h2><p><a href="https://screenzy.io/">Screenzy</a></p><p>Screenzy 支持将截图转换为带有渐变背景和阴影的精美图像。还提供一些定制选项，可以调整背景颜色、边框和截图大小，是一个轻量级的截图美化工具。</p><h2 id="Carbon"><a href="#Carbon" class="headerlink" title="Carbon"></a>Carbon</h2><p><a href="https://carbon.now.sh/">Carbon</a></p><p>Carbon 主要用于生成漂亮的代码截图。支持多种代码主题和字体样式，用户可以直接粘贴代码，选择配色方案，生成美观的代码图片，常被开发者用于分享技术内容。</p><h2 id="Codeimg"><a href="#Codeimg" class="headerlink" title="Codeimg"></a>Codeimg</h2><p><a href="https://codeimg.io/">codeimg</a> </p><p>作用同 Carbon</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上这些网站都可以帮助我们<strong>快速生成美观的截图效果</strong>，适合不同的使用场景：</p><ul><li><strong>产品展示</strong> → Shotsnapp、Mockuphone  </li><li><strong>截图美化</strong> → Screely、Screenzy  </li><li><strong>代码展示</strong> → Carbon</li></ul><p>它们都不需要安装软件，打开网页即可使用，非常适合设计师、开发者和内容创作者提升展示质量。</p>]]></content:encoded>
      
      
      <category domain="https://sharpmind.tech/categories/%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90/">工具推荐</category>
      
      
      <category domain="https://sharpmind.tech/tags/%E6%88%AA%E5%9B%BE%E5%B7%A5%E5%85%B7/">截图工具</category>
      
      <category domain="https://sharpmind.tech/tags/Mockup/">Mockup</category>
      
      <category domain="https://sharpmind.tech/tags/%E8%AE%BE%E8%AE%A1/">设计</category>
      
      <category domain="https://sharpmind.tech/tags/%E5%85%8D%E8%B4%B9%E5%B7%A5%E5%85%B7/">免费工具</category>
      
      
    </item>
    
    <item>
      <title>Swap是什么?如何分配?</title>
      <link>https://sharpmind.tech/Swap%E6%98%AF%E4%BB%80%E4%B9%88-%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D/</link>
      <guid>https://sharpmind.tech/Swap%E6%98%AF%E4%BB%80%E4%B9%88-%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D/</guid>
      <pubDate>Tue, 09 Sep 2025 07:33:01 GMT</pubDate>
      
      <description>Swap 是 Linux 系统中的虚拟内存机制，可以在物理内存不足时，临时使用硬盘空间来缓解压力。本文介绍 Swap 的概念、作用，以及常见的分配方法。</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="什么是-Swap？"><a href="#什么是-Swap？" class="headerlink" title="什么是 Swap？"></a>什么是 <strong>Swap</strong>？</h2><p>可以把服务器的内存（RAM）想象成一张桌子：</p><ul><li>内存大 → 桌子大 → 可以同时放很多书（程序&#x2F;数据）。</li><li>内存小 → 桌子小 → 书放不下。</li></ul><p><strong>Swap 就像是桌子旁边的抽屉（硬盘&#x2F;SSD 空间划出来的一块区域）</strong>：</p><ul><li>当桌子（内存）不够用时，系统会把暂时不用的书（数据）搬到抽屉里（Swap），腾出桌面空间。</li><li>等需要用的时候再拿回来。</li></ul><hr><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li><strong>优点</strong>：避免“桌子放不下时直接崩溃（OOM Kill）”，系统还能坚持下去。</li><li><strong>缺点</strong>：抽屉（Swap 在硬盘&#x2F;SSD）比桌子（RAM）慢很多倍，所以性能会下降。</li></ul><hr><h2 id="为什么你需要-Swap？"><a href="#为什么你需要-Swap？" class="headerlink" title="为什么你需要 Swap？"></a>为什么你需要 Swap？</h2><p>如果你的服务器（学生机）只有 <strong>2GB&#x2F;4GB 内存</strong>，但 Next.js 构建会瞬间吃 1~2GB+ 内存，超过就会触发 <strong>OOM Kill</strong>，导致你看到 SSH 掉线、服务挂掉。<br>👉 有了 Swap，就算物理内存满了，系统还能把一部分数据挪到硬盘里，不至于立刻杀进程。</p><hr><h2 id="怎么看有没有-Swap？"><a href="#怎么看有没有-Swap？" class="headerlink" title="怎么看有没有 Swap？"></a>怎么看有没有 Swap？</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -h</span><br></pre></td></tr></table></figure><p>输出里有一行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Swap:   0B   0B   0B</span><br></pre></td></tr></table></figure><p>说明还没开 Swap。<br>如果是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Swap:   4.0G   0B   4.0G</span><br></pre></td></tr></table></figure><p>说明有 4GB Swap，可以帮你缓冲。</p><h2 id="怎么加-Swap？"><a href="#怎么加-Swap？" class="headerlink" title="怎么加 Swap？"></a>怎么加 Swap？</h2><p>常见操作（给 4GB swap）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个 4GB 的文件当作 swap 空间</span></span><br><span class="line"><span class="built_in">sudo</span> fallocate -l 4G /swapfile</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> 600 /swapfile</span><br><span class="line"><span class="built_in">sudo</span> mkswap /swapfile</span><br><span class="line"><span class="built_in">sudo</span> swapon /swapfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机自动挂载</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;/swapfile none swap sw 0 0&#x27;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> -a /etc/fstab</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">free -h</span><br></pre></td></tr></table></figure><p>✅ 总结：<br>Swap 就是“虚拟内存”，用硬盘空间临时当内存，解决内存不足导致的崩溃问题。它不会让程序更快，但能让小内存机器更稳，不至于一跑构建就挂。</p><h2 id="适用于Ubuntu系统的脚本"><a href="#适用于Ubuntu系统的脚本" class="headerlink" title="适用于Ubuntu系统的脚本"></a>适用于Ubuntu系统的脚本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查并创建 Swap 脚本</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用法：<span class="built_in">sudo</span> bash check_or_create_swap.sh</span></span><br><span class="line"></span><br><span class="line">SWAPFILE=&quot;/swapfile&quot;</span><br><span class="line">SIZE=&quot;4G&quot;   # 可以改成 2G、8G</span><br><span class="line"></span><br><span class="line">echo &quot;&gt;&gt;&gt; 检查当前 Swap 状态...&quot;</span><br><span class="line">free -h</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">判断是否已经有 swap</span></span><br><span class="line">if swapon --show | grep -q &quot;$SWAPFILE&quot;; then</span><br><span class="line">    echo &quot;&gt;&gt;&gt; 已经存在 $SWAPFILE，不需要再创建。&quot;</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ &quot;$(swapon --show | wc -l)&quot; -gt 0 ]; then</span><br><span class="line">    echo &quot;&gt;&gt;&gt; 系统已经有其它 Swap，不需要再创建。&quot;</span><br><span class="line">    swapon --show</span><br><span class="line">    exit 0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;&gt;&gt;&gt; 没有发现 Swap，开始创建 $&#123;SIZE&#125; swap 文件...&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建 swapfile</span></span><br><span class="line">fallocate -l $SIZE $SWAPFILE</span><br><span class="line">chmod 600 $SWAPFILE</span><br><span class="line">mkswap $SWAPFILE</span><br><span class="line">swapon $SWAPFILE</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置开机自动挂载</span></span><br><span class="line">if ! grep -q &quot;$SWAPFILE&quot; /etc/fstab; then</span><br><span class="line">    echo &quot;$SWAPFILE none swap sw 0 0&quot; &gt;&gt; /etc/fstab</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;&gt;&gt;&gt; 创建完成，当前 Swap 状态：&quot;</span><br><span class="line">free -h</span><br><span class="line">swapon --show</span><br></pre></td></tr></table></figure><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol><li><p>在服务器上创建脚本文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim check_or_create_swap.sh</span><br></pre></td></tr></table></figure><p>把上面内容粘贴进去，保存退出。</p></li><li><p>赋予可执行权限：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x check_or_create_swap.sh</span><br></pre></td></tr></table></figure></li><li><p>用 root 权限运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> ./check_or_create_swap.sh</span><br></pre></td></tr></table></figure></li><li><p>脚本会：</p><ul><li>显示当前 swap 状态</li><li>如果没有，就自动创建一个 4GB 的 <code>/swapfile</code></li><li>启用并写入 <code>/etc/fstab</code>，确保开机自动生效</li><li>最后再显示新的 swap 状态</li></ul></li></ol><hr><p>⚠️ 提示：</p><ul><li>如果你的服务器硬盘空间比较小，可以把 <code>SIZE=&quot;4G&quot;</code> 改成 <code>2G</code>。</li><li>如果要更稳（比如跑很多构建任务），可以改成 <code>8G</code>。</li><li>查看整体磁盘挂载情况命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br></pre></td></tr></table></figure><ul><li>df &#x3D; disk free</li><li>-h &#x3D; human readable（人类可读，显示 GB&#x2F;MB）</li></ul><p>示例输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/vda1        40G   15G   23G  40% /</span><br><span class="line">tmpfs           987M     0  987M   0% /dev/shm</span><br></pre></td></tr></table></figure><ul><li>Size：磁盘总大小</li><li>Used：已用空间</li><li>Avail：剩余可用空间</li><li>Use%：使用率</li><li>Mounted on：挂载点（&#x2F; 就是根目录，主要看这个）</li></ul>]]></content:encoded>
      
      
      <category domain="https://sharpmind.tech/categories/%E8%BF%90%E7%BB%B4%E9%83%A8%E7%BD%B2/">运维部署</category>
      
      
      <category domain="https://sharpmind.tech/tags/Linux/">Linux</category>
      
      <category domain="https://sharpmind.tech/tags/%E8%BF%90%E7%BB%B4/">运维</category>
      
      <category domain="https://sharpmind.tech/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</category>
      
      <category domain="https://sharpmind.tech/tags/Swap/">Swap</category>
      
      
    </item>
    
    <item>
      <title>服务器OOM(Out Of Memory)</title>
      <link>https://sharpmind.tech/%E6%9C%8D%E5%8A%A1%E5%99%A8OOM-Out-Of-Memory/</link>
      <guid>https://sharpmind.tech/%E6%9C%8D%E5%8A%A1%E5%99%A8OOM-Out-Of-Memory/</guid>
      <pubDate>Tue, 09 Sep 2025 07:15:48 GMT</pubDate>
      
      <description>记录服务器因内存不足触发 OOM Kill 的情况，以及相关解决思路。</description>
      
      
      
      <content:encoded><![CDATA[<p>如果你出现（<strong>SSH 连不上 + 网站也挂了 + 过几分钟恢复</strong>），在小内存服务器上跑 <code>next build</code> 时非常常见，基本就是 <strong>服务器被 OOM（Out Of Memory）卡死&#x2F;杀进程</strong> 了。</p><p>下面教你几种方法确认是不是“崩溃”以及从哪里看日志：</p><hr><h2 id="1-看系统是否因为内存不足杀了进程（最重要）"><a href="#1-看系统是否因为内存不足杀了进程（最重要）" class="headerlink" title="1. 看系统是否因为内存不足杀了进程（最重要）"></a>1. 看系统是否因为内存不足杀了进程（最重要）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看内核日志里是否有 OOM Kill</span></span><br><span class="line">dmesg -T | grep -i -E <span class="string">&quot;killed process|out of memory|oom&quot;</span></span><br></pre></td></tr></table></figure><p>如果你看到类似：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Mon Sep 9 12:34:56 2025] Out of memory: Killed process 12345 (node) total-vm:...</span><br></pre></td></tr></table></figure><p>就说明是 <code>node</code>（Next.js 构建进程）被 OOM 杀掉，期间系统可能卡死，导致你无法 SSH 和访问网站。</p><p>这就是 OOM Killer（内存不足杀进程） 的记录。</p><p>也就是说你的服务器没有真正“重启”，而是 内存用光 → 系统进入 OOM → 把正在吃内存的进程杀掉（node、甚至 networkmanager 都被杀）。</p><p>在这个过程中，服务器会卡死几分钟，SSH 和网站都连不上，所以你看到“崩溃”的现象。</p><h2 id="2-查看系统日志"><a href="#2-查看系统日志" class="headerlink" title="2. 查看系统日志"></a>2. 查看系统日志</h2><p>不同系统日志位置略有差异：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果用 systemd（Ubuntu 20+/22+ 默认）</span></span><br><span class="line">journalctl -xe --since <span class="string">&quot;10 minutes ago&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你知道大概出问题的时间段，可以指定时间</span></span><br><span class="line">journalctl -xe --since <span class="string">&quot;2025-09-09 12:30:00&quot;</span> --<span class="keyword">until</span> <span class="string">&quot;2025-09-09 12:40:00&quot;</span></span><br></pre></td></tr></table></figure><p>重点留意里面是否有：</p><ul><li><code>Out of memory</code></li><li><code>oom-killer</code></li><li><code>kernel: Killed process ...</code></li><li>服务器 CPU&#x2F;内存 100% 导致 sshd&#x2F;nginx 等服务暂时停顿</li></ul><h2 id="3-看是否是机器直接重启了"><a href="#3-看是否是机器直接重启了" class="headerlink" title="3. 看是否是机器直接重启了"></a>3. 看是否是机器直接重启了</h2><p>如果怀疑整台服务器重启过，可以查开机时间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uptime</span> -s   <span class="comment"># 上次开机时间</span></span><br><span class="line">last reboot <span class="comment"># 重启记录</span></span><br></pre></td></tr></table></figure><p>如果时间点跟你掉线的时间一致，就是重启了。<br>如果没重启，但掉线，那就是 OOM 卡死，过一会内核恢复。</p><hr><h2 id="4-查看服务级别的日志"><a href="#4-查看服务级别的日志" class="headerlink" title="4. 查看服务级别的日志"></a>4. 查看服务级别的日志</h2><p>比如你跑的网站用 <code>pm2</code> &#x2F; <code>docker</code> &#x2F; <code>systemd</code> 托管：</p><ul><li><p><strong>Docker</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br><span class="line">docker logs &lt;container_id&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>PM2</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm2 logs</span><br></pre></td></tr></table></figure></li><li><p><strong>systemd service</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -u your-service-name --since <span class="string">&quot;10 minutes ago&quot;</span></span><br></pre></td></tr></table></figure></li></ul><p>✅ <strong>总结：</strong></p><ul><li>先用 <code>dmesg -T | grep -i -E &quot;killed process|oom&quot;</code> 确认是不是内存不足。</li><li>再用 <code>journalctl</code> 对照具体时间看是否有 OOM Kill 或重启记录。</li><li>如果确认是 OOM，以后就需要 <strong>加 swap &#x2F; 增内存 &#x2F; 降低构建时内存占用</strong></li></ul><p>如何添加Swap？请参考👉<a href="https://sharpmind.tech/2025/09/09/Swap%E6%98%AF%E4%BB%80%E4%B9%88-%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D/">这篇文章</a></p>]]></content:encoded>
      
      
      <category domain="https://sharpmind.tech/categories/%E8%BF%90%E7%BB%B4%E9%83%A8%E7%BD%B2/">运维部署</category>
      
      
      <category domain="https://sharpmind.tech/tags/Linux/">Linux</category>
      
      <category domain="https://sharpmind.tech/tags/%E8%BF%90%E7%BB%B4/">运维</category>
      
      <category domain="https://sharpmind.tech/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">内存管理</category>
      
      <category domain="https://sharpmind.tech/tags/OOM/">OOM</category>
      
      
    </item>
    
    <item>
      <title>解决 git push 出现 port 22: Connection timed out</title>
      <link>https://sharpmind.tech/git-push-github-com-port-22-Connection-timed-out-fatal/</link>
      <guid>https://sharpmind.tech/git-push-github-com-port-22-Connection-timed-out-fatal/</guid>
      <pubDate>Mon, 08 Sep 2025 10:45:48 GMT</pubDate>
      
      <description>当使用 git push 或 git clone 出现 &quot;ssh: connect to host github.com port 22: Connection timed out&quot; 报错时的原因分析与解决方案，并科普端口 22 和 443 的区别。</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>在日常使用 GitHub 的时候，有时会遇到这样的报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ssh: connect to host github.com port 22: Operation timed out</span><br><span class="line">fatal: Could not <span class="built_in">read</span> from remote repository.</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">我在测试时发现两种情况：</span><br><span class="line"></span><br><span class="line">* **关闭代理时**：</span><br><span class="line"></span><br><span class="line">  ```bash</span><br><span class="line">  git <span class="built_in">clone</span> git@github.com:kxzb-fun/ks.git</span><br><span class="line">  ssh: connect to host github.com port 22: Operation timed out</span><br></pre></td></tr></table></figure><p>  → 直连 <code>github.com:22</code> 超时。</p><ul><li><p><strong>打开代理时</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:kxzb-fun/ks.git</span><br><span class="line">Connection closed by 127.0.0.1 port 7890</span><br></pre></td></tr></table></figure><p>→ 说明流量被代理劫持到了本地端口 <code>127.0.0.1:7890</code>，但代理并没有正确处理 SSH，连接被直接关闭。</p></li></ul><p>结论：<br><strong>22 端口被网络环境屏蔽，而代理又不支持 SSH 转发，导致 push&#x2F;pull 都失败。</strong></p><h2 id="解决方案：使用-SSH-的-443-端口"><a href="#解决方案：使用-SSH-的-443-端口" class="headerlink" title="解决方案：使用 SSH 的 443 端口"></a>解决方案：使用 SSH 的 443 端口</h2><p>GitHub 默认用 22 端口提供 SSH 服务，但也贴心地在 <code>ssh.github.com:443</code> 提供了备用通道，专门为 22 被封的情况准备。</p><ol><li><p>编辑 SSH 配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.ssh/config</span><br></pre></td></tr></table></figure><p>添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  HostName ssh.github.com</span><br><span class="line">  Port 443</span><br><span class="line">  User git</span><br><span class="line">  IdentityFile ~/.ssh/id_ed25519   # 或 ~/.ssh/id_rsa，按实际私钥</span><br><span class="line">  IdentitiesOnly yes</span><br><span class="line">  ServerAliveInterval 60</span><br></pre></td></tr></table></figure></li><li><p>测试连通：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果返回：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi &lt;username&gt;! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure><p>就说明 SSH 已经能正常连通。</p></li><li><p>之后正常使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br><span class="line">git pull</span><br><span class="line">git <span class="built_in">clone</span> git@github.com:&lt;username&gt;/&lt;repo&gt;.git</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="22-端口和-443-端口的区别"><a href="#22-端口和-443-端口的区别" class="headerlink" title="22 端口和 443 端口的区别"></a>22 端口和 443 端口的区别</h2><ul><li><p><strong>22 端口</strong></p><ul><li>默认用于 <strong>SSH 协议</strong>。</li><li>GitHub 的 <code>git@github.com:xxx/xxx.git</code> 默认就是走 22。</li></ul></li><li><p><strong>443 端口</strong></p><ul><li>默认用于 <strong>HTTPS 协议（SSL&#x2F;TLS 加密）</strong>。</li><li>但 GitHub 在 <code>ssh.github.com:443</code> 上 <strong>额外挂载了 SSH 服务</strong>，让 SSH 可以“伪装”成走 443，从而绕过防火墙限制。</li></ul></li></ul><p>所以，当你在 <code>~/.ssh/config</code> 里改成 443 时，走的依然是 <strong>SSH 协议</strong>，只是端口换成了 443。</p><hr><h2 id="为什么-22-容易被屏蔽？"><a href="#为什么-22-容易被屏蔽？" class="headerlink" title="为什么 22 容易被屏蔽？"></a>为什么 22 容易被屏蔽？</h2><ul><li><strong>安全管控</strong>：公司、学校、公共 Wi-Fi 常常屏蔽 22，防止用户绕过内网直接 SSH 出去。</li><li><strong>翻墙限制</strong>：有些地区的网络会专门封 22，因为很多代理&#x2F;隧道工具喜欢伪装成 SSH。</li><li><strong>运营商策略</strong>：部分 ISP 屏蔽家庭宽带的 22，避免用户自己搭建服务器。</li><li><strong>公共网络策略</strong>：咖啡厅、机场的 Wi-Fi 通常只开放 80 和 443，其他端口一律禁止。</li></ul><p>而 443 端口几乎不会被封，因为它是网页加密访问的必需端口。</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><code>ssh: connect to host github.com port 22: Connection timed out</code> 的核心原因是 <strong>22 端口被屏蔽</strong>。</li><li>代理（127.0.0.1:7890）如果不支持 SSH，就会导致 <strong>Connection closed</strong>。</li><li>最佳解决方案：修改 <code>~/.ssh/config</code>，改用 <strong>SSH over 443</strong>。</li><li>443 是 HTTPS 默认端口，但 GitHub 特意在 443 上也提供了 SSH 服务，用来绕过限制。</li></ol><p>这样就能在任何网络环境下顺利 <code>git push / pull / clone</code> 了 🚀</p>]]></content:encoded>
      
      
      <category domain="https://sharpmind.tech/categories/%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0/">技术笔记</category>
      
      
      <category domain="https://sharpmind.tech/tags/github/">github</category>
      
      <category domain="https://sharpmind.tech/tags/ssh/">ssh</category>
      
      <category domain="https://sharpmind.tech/tags/git/">git</category>
      
      <category domain="https://sharpmind.tech/tags/%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/">网络问题</category>
      
      
    </item>
    
    <item>
      <title>Mac电脑上如何修改主机名称</title>
      <link>https://sharpmind.tech/Mac%E7%94%B5%E8%84%91%E4%B8%8A%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E4%B8%BB%E6%9C%BA%E5%90%8D%E7%A7%B0/</link>
      <guid>https://sharpmind.tech/Mac%E7%94%B5%E8%84%91%E4%B8%8A%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9%E4%B8%BB%E6%9C%BA%E5%90%8D%E7%A7%B0/</guid>
      <pubDate>Sat, 06 Sep 2025 07:14:28 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;在我们新拿到Mac电脑或者重置系统后，打开终端(Terminal)会发现 里的 shell 提示符变成奇奇怪的数字&lt;/p&gt;
&lt;p&gt;比如 &lt;code&gt;junhua@192~&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;junhua@192~</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>在我们新拿到Mac电脑或者重置系统后，打开终端(Terminal)会发现 里的 shell 提示符变成奇奇怪的数字</p><p>比如 <code>junhua@192~</code></p><p>junhua@192~ 这个shell提示符对于的含义，其中：</p><ul><li>junhua 👉 你当前登录的用户名</li><li>192 👉 你的电脑主机名 (hostname)</li><li><code>~</code> 👉 当前所在目录（这里的 ~ 是 home 目录的简写）</li></ul><h2 id="为什么会自动出现-192？"><a href="#为什么会自动出现-192？" class="headerlink" title="为什么会自动出现 192？"></a>为什么会自动出现 192？</h2><p>当 Mac 没有正确配置主机名，或者在网络中名字冲突时，macOS 会自动给主机名起一个简短名字，例如：192、192-168-1-2 之类。</p><h2 id="修改方法"><a href="#修改方法" class="headerlink" title="修改方法"></a>修改方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> scutil --<span class="built_in">set</span> HostName MacBookPro</span><br></pre></td></tr></table></figure><p>修改之后需要重启终端，这样就会看到 <code>junhua@MacBookPro ~</code>，这样就是感觉好多了。</p><h2 id="Mac电脑三个主机名称"><a href="#Mac电脑三个主机名称" class="headerlink" title="Mac电脑三个主机名称"></a>Mac电脑三个主机名称</h2><p>除了<code>HostName</code>还有另外两个值<code>ComputerName</code>和<code>LocalHostName</code>，其实是 <strong>macOS 对“电脑名字”的三个不同层次的定义</strong>。它们的作用场景不一样，所以经常会看到显示结果不一致。</p><p>我们可以通过以下命令获取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scutil --get ComputerName</span><br><span class="line"><span class="comment">#junhua的MacBook Pro</span></span><br><span class="line">scutil --get HostName</span><br><span class="line"><span class="comment">#MBPro</span></span><br><span class="line">scutil --get LocalHostName</span><br><span class="line"><span class="comment">#junhuaMBP</span></span><br></pre></td></tr></table></figure><hr><h3 id="🔹-1-ComputerName"><a href="#🔹-1-ComputerName" class="headerlink" title="🔹 1. ComputerName"></a>🔹 1. <code>ComputerName</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">junhua的MacBook Pro</span><br></pre></td></tr></table></figure><ul><li>这是你在 <strong>系统设置 → 通用 → 共享</strong> 里看到的 <strong>电脑名称</strong>。</li><li>主要作用：显示给 <strong>本机用户</strong>，或者在 <strong>AirDrop &#x2F; Finder 共享</strong> 时出现。</li><li>可以包含中文、空格、特殊字符。</li></ul><hr><h3 id="🔹-2-LocalHostName"><a href="#🔹-2-LocalHostName" class="headerlink" title="🔹 2. LocalHostName"></a>🔹 2. <code>LocalHostName</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">junhuaMBP</span><br></pre></td></tr></table></figure><ul><li><p>这是本地网络中的 <strong>Bonjour 名称</strong>（也叫 <strong>本地主机名</strong>）。</p></li><li><p>用来在 <strong>局域网内发现服务</strong>，一般对应 <code>.local</code> 域名。</p><ul><li>比如你可以在局域网的另一台 Mac 上 <code>ping junhuaMBP.local</code>。</li></ul></li><li><p>只能使用 <strong>字母、数字和中横线</strong>，不能有空格或中文。</p></li><li><p>在“共享”设置里，如果你改了电脑名，这个值通常也会自动变化。</p></li></ul><hr><h3 id="🔹-3-HostName"><a href="#🔹-3-HostName" class="headerlink" title="🔹 3. HostName"></a>🔹 3. <code>HostName</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MBPro</span><br></pre></td></tr></table></figure><ul><li>这是 <strong>系统级别的主机名</strong>，一般用于 <strong>终端 &#x2F; SSH &#x2F; 脚本</strong>。</li><li>默认情况下，这个值是<strong>空的</strong>，macOS 会自动回退到 <code>LocalHostName</code>。</li><li>如果你手动设置过，就会覆盖默认值（比如你现在的就是 <code>MBPro</code>）。</li><li>常用于命令行里的提示符（<code>junhua@MBPro ~</code> 就是用的这个）。</li></ul><hr><h3 id="🔎-总结对比表"><a href="#🔎-总结对比表" class="headerlink" title="🔎 总结对比表"></a>🔎 总结对比表</h3><table><thead><tr><th>名称</th><th>作用范围</th><th>例子</th><th>特点</th></tr></thead><tbody><tr><td><strong>ComputerName</strong></td><td>显示用（系统界面、AirDrop、Finder）</td><td><code>junhua的MacBook Pro</code></td><td>可以有中文、空格</td></tr><tr><td><strong>LocalHostName</strong></td><td>局域网 Bonjour &#x2F; <code>.local</code> 地址</td><td><code>junhuaMBP.local</code></td><td>无中文、无空格</td></tr><tr><td><strong>HostName</strong></td><td>终端&#x2F;SSH&#x2F;系统级别主机名</td><td><code>MBPro</code></td><td>默认空，可手动设置</td></tr></tbody></table><hr><p>👉 所以你会看到：</p><ul><li>Finder 里别人看到的是 <strong><code>junhua的MacBook Pro</code></strong></li><li>局域网服务里你是 <strong><code>junhuaMBP.local</code></strong></li><li>终端提示符里是 <strong><code>MBPro</code></strong></li></ul><h2 id="scutil命令"><a href="#scutil命令" class="headerlink" title="scutil命令"></a>scutil命令</h2><p><code>scutil</code> <strong>不是 Linux 命令</strong>，它是 <strong>macOS 特有的系统配置工具</strong>，全称 <strong>System Configuration Utility</strong>。<br>它的作用是直接操作 macOS 的 <strong>SystemConfiguration 框架</strong>，用来读写系统数据。</p>]]></content:encoded>
      
      
      
      
    </item>
    
    <item>
      <title>关于npm create 和 Vite</title>
      <link>https://sharpmind.tech/%E5%85%B3%E4%BA%8Enpm-create-%E5%92%8C-Vite/</link>
      <guid>https://sharpmind.tech/%E5%85%B3%E4%BA%8Enpm-create-%E5%92%8C-Vite/</guid>
      <pubDate>Fri, 05 Sep 2025 03:25:55 GMT</pubDate>
      
      <description>本文主要梳理了 `npm create` 的功能，对比了 `create-react-app` 和 `create-vite` 的区别，并简单的实现了一个 `create-myvite` 的库学习创建逻辑。</description>
      
      
      
      <content:encoded><![CDATA[<p>本文主要梳理了 <code>npm create</code> 的功能，对比了 <code>create-react-app</code> 和 <code>create-vite</code> 的区别，并简单的实现了一个 <code>create-myvite</code> 的库学习创建逻辑。</p><h2 id="从npm-create-说起"><a href="#从npm-create-说起" class="headerlink" title="从npm create 说起"></a>从npm create 说起</h2><p><code>npm create</code>是npm命令的一部分，用于通过npm运行特定的脚本或包来创建新的项目。它简化了创建项目的过程，特别是当你需要基于某个模板或特定工具来初始化项目时。</p><p>比如我们执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create xxx</span><br></pre></td></tr></table></figure><ol><li><strong><code>npm create</code></strong>:<ul><li><code>npm</code>是Node Package Manager的缩写，用于管理JavaScript包。</li><li><code>create</code>是一个关键字，表示你要运行一个创建项目的脚本。</li></ul></li><li><strong><code>xxx</code></strong>:<ul><li><code>xxx</code>表示你要使用的创建器包的名称。这可以是<code>vite</code>，也可以是其他任何支持<code>npm create</code>命令的创建器包。</li></ul></li></ol><p>当你运行<code>npm create xxx</code>时，npm会执行以下步骤：</p><ol><li><strong>查找并下载创建器包</strong>：<ul><li>npm会从注册表中下载名为<code>create-xxx</code>的包。例如，如果你运行<code>npm create vite</code>，npm实际上会查找并使用<code>create-vite</code>包。</li></ul></li><li><strong>执行创建器包的逻辑</strong>：<ul><li>下载并安装<code>create-xxx</code>包后，npm会运行该包的创建脚本。这通常会涉及到询问用户一些问题（如项目名称、模板选择等），然后根据用户的输入来生成项目结构和文件。</li></ul></li></ol><h2 id="create-vite-这个包具体做了什么"><a href="#create-vite-这个包具体做了什么" class="headerlink" title="create-vite 这个包具体做了什么"></a>create-vite 这个包具体做了什么</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm create vite@latest part1 -- --template react</span><br></pre></td></tr></table></figure><p>这个命令用于通过Vite创建一个新的React项目。让我们逐步解释每个部分的含义：</p><ol><li><code>vite@latest</code>确保使用的是最新发布的版本。</li><li><strong>part1</strong>: 这是新项目的名称。在这个例子中，项目将被创建在一个名为<code>part1</code>的文件夹中。</li><li><strong>– –template react</strong>: 这部分指定了模板。<code>--template react</code>告诉Vite使用React模板来初始化项目。这意味着生成的项目将已经配置好React的相关依赖和文件结构。</li></ol><h3 id="询问用户输入"><a href="#询问用户输入" class="headerlink" title="询问用户输入"></a>询问用户输入</h3><p>当你运行 <code>npm create vite@latest</code> 时，<code>create-vite</code> 包会启动一个命令行交互界面，询问你一些基本问题，比如项目名称、要使用的模板（如 React、Vue、Svelte 等）以及其他配置选项。</p><h3 id="创建项目目录和文件"><a href="#创建项目目录和文件" class="headerlink" title="创建项目目录和文件"></a>创建项目目录和文件</h3><ul><li>根据用户输入，<code>create-vite</code> 会在指定的目录下生成项目结构和文件。这些文件包括：</li><li><code>package.json</code>：定义项目的元数据和依赖。</li><li><code>index.html</code>：项目的入口 HTML 文件。</li><li><code>src</code> 目录：包含源代码，通常会包含一个基本的 <code>main.js</code> 或 <code>main.ts</code> 文件，以及一个示例组件。</li><li>配置文件：如 <code>vite.config.js</code> 或 <code>vite.config.ts</code>，用于配置 Vite。</li></ul><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><p>如果你选择了特定的模板，<code>create-vite</code> 会自动添加相关的依赖到 <code>package.json</code> 中，并且会提供安装依赖的提示</p><h3 id="提供运行指令"><a href="#提供运行指令" class="headerlink" title="提供运行指令"></a>提供运行指令</h3><p>创建项目后，<code>create-vite</code> 会提示你下一步的操作，例如进入项目目录并运行开发服务器的命令（通常是 <code>npm install</code> 然后 <code>npm run dev</code>）。</p><h2 id="自己动手写一个脚手架"><a href="#自己动手写一个脚手架" class="headerlink" title="自己动手写一个脚手架"></a>自己动手写一个脚手架</h2><h3 id="步骤-1：初始化项目"><a href="#步骤-1：初始化项目" class="headerlink" title="步骤 1：初始化项目"></a>步骤 1：初始化项目</h3><p>首先，创建一个新的 Node.js 项目：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> create-myvite</span><br><span class="line"><span class="built_in">cd</span> create-myvite</span><br><span class="line">npm init -y</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="步骤-2：安装依赖"><a href="#步骤-2：安装依赖" class="headerlink" title="步骤 2：安装依赖"></a>步骤 2：安装依赖</h3><p>安装所需的依赖库，比如 <code>inquirer</code> 用于命令行交互，<code>fs-extra</code> 用于文件操作：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install inquirer fs-extra</span><br></pre></td></tr></table></figure><h3 id="步骤-3：编写脚本"><a href="#步骤-3：编写脚本" class="headerlink" title="步骤 3：编写脚本"></a>步骤 3：编写脚本</h3><p>index.mjs 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> inquirer <span class="keyword">from</span> <span class="string">&#x27;inquirer&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs-extra&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; fileURLToPath &#125; <span class="keyword">from</span> <span class="string">&#x27;url&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// These lines are necessary to get __dirname in an ES module</span></span><br><span class="line"><span class="keyword">const</span> __filename = <span class="title function_">fileURLToPath</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>);</span><br><span class="line"><span class="keyword">const</span> __dirname = path.<span class="title function_">dirname</span>(__filename);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">createProject</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> answers = <span class="keyword">await</span> inquirer.<span class="title function_">prompt</span>([</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;input&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;projectName&#x27;</span>,</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;Project name:&#x27;</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="string">&#x27;my-vite-project&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;list&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;template&#x27;</span>,</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;Select a template:&#x27;</span>,</span><br><span class="line">      <span class="attr">choices</span>: [<span class="string">&#x27;vanilla&#x27;</span>, <span class="string">&#x27;react&#x27;</span>, <span class="string">&#x27;vue&#x27;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; projectName, template &#125; = answers;</span><br><span class="line">  <span class="keyword">const</span> projectPath = path.<span class="title function_">join</span>(process.<span class="title function_">cwd</span>(), projectName);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fs.<span class="title function_">existsSync</span>(projectPath)) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`Error: Directory <span class="subst">$&#123;projectName&#125;</span> already exists.`</span>);</span><br><span class="line">    process.<span class="title function_">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fs.<span class="title function_">mkdirSync</span>(projectPath);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a basic Vite project structure</span></span><br><span class="line">  fs.<span class="title function_">writeFileSync</span>(path.<span class="title function_">join</span>(projectPath, <span class="string">&#x27;index.html&#x27;</span>), <span class="string">`&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">&lt;html lang=&quot;en&quot;&gt;</span></span><br><span class="line"><span class="string">  &lt;head&gt;</span></span><br><span class="line"><span class="string">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span></span><br><span class="line"><span class="string">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span></span><br><span class="line"><span class="string">    &lt;title&gt;Vite App&lt;/title&gt;</span></span><br><span class="line"><span class="string">  &lt;/head&gt;</span></span><br><span class="line"><span class="string">  &lt;body&gt;</span></span><br><span class="line"><span class="string">    &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">    &lt;script type=&quot;module&quot; src=&quot;/src/main.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">  &lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> dependencies = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> devDependencies = &#123;</span><br><span class="line">    <span class="attr">vite</span>: <span class="string">&quot;^3.0.0&quot;</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> srcDir = path.<span class="title function_">join</span>(projectPath, <span class="string">&#x27;src&#x27;</span>);</span><br><span class="line">  fs.<span class="title function_">mkdirSync</span>(srcDir);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (template === <span class="string">&#x27;react&#x27;</span>) &#123;</span><br><span class="line">    dependencies.<span class="property">react</span> = <span class="string">&#x27;^17.0.0&#x27;</span>;</span><br><span class="line">    dependencies[<span class="string">&#x27;react-dom&#x27;</span>] = <span class="string">&#x27;^17.0.0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    fs.<span class="title function_">writeFileSync</span>(path.<span class="title function_">join</span>(srcDir, <span class="string">&#x27;main.jsx&#x27;</span>), <span class="string">`import React from &#x27;react&#x27;;</span></span><br><span class="line"><span class="string">import ReactDOM from &#x27;react-dom&#x27;;</span></span><br><span class="line"><span class="string">import App from &#x27;./App&#x27;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ReactDOM.createRoot(document.getElementById(&#x27;app&#x27;)).render(&lt;App /&gt;);`</span>);</span><br><span class="line"></span><br><span class="line">    fs.<span class="title function_">writeFileSync</span>(path.<span class="title function_">join</span>(srcDir, <span class="string">&#x27;App.jsx&#x27;</span>), <span class="string">`import React from &#x27;react&#x27;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function App() &#123;</span></span><br><span class="line"><span class="string">  return &lt;h1&gt;Hello, Vite + React!&lt;/h1&gt;;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default App;`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template === <span class="string">&#x27;vue&#x27;</span>) &#123;</span><br><span class="line">    dependencies.<span class="property">vue</span> = <span class="string">&#x27;^3.0.0&#x27;</span>;</span><br><span class="line">    devDependencies[<span class="string">&#x27;@vitejs/plugin-vue&#x27;</span>] = <span class="string">&#x27;^2.0.0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    fs.<span class="title function_">writeFileSync</span>(path.<span class="title function_">join</span>(srcDir, <span class="string">&#x27;main.js&#x27;</span>), <span class="string">`import &#123; createApp &#125; from &#x27;vue&#x27;;</span></span><br><span class="line"><span class="string">import App from &#x27;./App.vue&#x27;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">createApp(App).mount(&#x27;#app&#x27;);`</span>);</span><br><span class="line"></span><br><span class="line">    fs.<span class="title function_">writeFileSync</span>(path.<span class="title function_">join</span>(srcDir, <span class="string">&#x27;App.vue&#x27;</span>), <span class="string">`&lt;template&gt;</span></span><br><span class="line"><span class="string">  &lt;h1&gt;Hello, Vite + Vue!&lt;/h1&gt;</span></span><br><span class="line"><span class="string">&lt;/template&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;script&gt;</span></span><br><span class="line"><span class="string">export default &#123;</span></span><br><span class="line"><span class="string">  name: &#x27;App&#x27;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">&lt;/script&gt;`</span>);</span><br><span class="line"></span><br><span class="line">    fs.<span class="title function_">writeFileSync</span>(path.<span class="title function_">join</span>(projectPath, <span class="string">&#x27;vite.config.js&#x27;</span>), <span class="string">`import &#123; defineConfig &#125; from &#x27;vite&#x27;;</span></span><br><span class="line"><span class="string">import vue from &#x27;@vitejs/plugin-vue&#x27;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default defineConfig(&#123;</span></span><br><span class="line"><span class="string">  plugins: [vue()]</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">`</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fs.<span class="title function_">writeFileSync</span>(path.<span class="title function_">join</span>(srcDir, <span class="string">&#x27;main.js&#x27;</span>), <span class="string">`document.getElementById(&#x27;app&#x27;).innerHTML = &#x27;&lt;h1&gt;Hello, Vite!&lt;/h1&gt;&#x27;;`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fs.<span class="title function_">writeFileSync</span>(</span><br><span class="line">    path.<span class="title function_">join</span>(projectPath, <span class="string">&quot;package.json&quot;</span>),</span><br><span class="line">    <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: projectName,</span><br><span class="line">      <span class="attr">version</span>: <span class="string">&quot;0.0.1&quot;</span>,</span><br><span class="line">      <span class="attr">scripts</span>: &#123;</span><br><span class="line">        <span class="attr">dev</span>: <span class="string">&quot;vite&quot;</span>,</span><br><span class="line">        <span class="attr">build</span>: <span class="string">&quot;vite build&quot;</span>,</span><br><span class="line">        <span class="attr">serve</span>: <span class="string">&quot;vite preview&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      dependencies,</span><br><span class="line">      devDependencies</span><br><span class="line">    &#125;, <span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Project <span class="subst">$&#123;projectName&#125;</span> created successfully.`</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Navigate to the project directory and run &#x27;npm install&#x27; to install dependencies.`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">createProject</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>package.json文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;create-myvite&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;module&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index.mjs&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;bin&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;create-myvite&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./index.mjs&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;inquirer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^8.1.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;fs-extra&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^10.0.0&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="步骤-4：添加执行权限和链接"><a href="#步骤-4：添加执行权限和链接" class="headerlink" title="步骤 4：添加执行权限和链接"></a>步骤 4：添加执行权限和链接</h3><p>使 <code>index.mjs</code> 文件可执行，并创建全局链接：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x index.mjs</span><br><span class="line">npm <span class="built_in">link</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="运行示例"><a href="#运行示例" class="headerlink" title="运行示例"></a>运行示例</h3><p>运行以下命令来创建一个新项目：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-myvite</span><br></pre></td></tr></table></figure><h2 id="create-vite-和-CRA（create-react-app）比较"><a href="#create-vite-和-CRA（create-react-app）比较" class="headerlink" title="create-vite 和 CRA（create-react-app）比较"></a><code>create-vite</code> 和 CRA（<code>create-react-app</code>）比较</h2><h3 id="相似之处"><a href="#相似之处" class="headerlink" title="相似之处"></a>相似之处</h3><ol><li><strong>快速搭建应用程序：</strong> 两者都旨在简化新项目的搭建过程。通过运行一个命令，你可以快速创建一个基本的项目结构，并且可以立即开始编写代码。</li><li><strong>现代化的工具链：</strong> 两者都使用了现代化的工具链，包括 Babel、Webpack、ESLint 等，以确保你可以使用最新的 JavaScript 特性，并且具备良好的开发体验。</li><li><strong>默认配置：</strong> 默认情况下，它们提供了一个预配置的开发环境，包括热重载、代码分割、生产构建等功能。</li></ol><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li><strong>构建工具：</strong> 最明显的区别是它们使用的构建工具不同。<code>create-react-app</code> 使用的是 Webpack，而 <code>create-vite</code> 使用的是 Vite。Vite 是一个由 Vue.js 核心团队开发的新型前端构建工具，它利用了现代浏览器对 ES 模块的原生支持，能够实现非常快速的开发构建速度。</li><li><strong>模块热更新（HMR）：</strong> <code>create-vite</code> 基于 Vite，利用了浏览器原生支持的 ES 模块特性，因此具有更快的热更新速度。而 <code>create-react-app</code> 使用的 HMR 则是基于 Webpack 的实现，速度相对较慢。</li><li><strong>生态系统：</strong> 由于 <code>create-react-app</code> 是由 Facebook 团队维护的，因此它更倾向于与 React 生态系统无缝集成。相比之下，<code>create-vite</code> 在刚推出时可能会受到生态系统限制，但由于 Vite 本身已经得到了 Vue.js 社区的广泛支持，因此其生态系统也在不断壮大。</li><li><strong>生产构建方式：</strong> <code>create-react-app</code> 使用 Webpack 来构建生产环境的代码，而 <code>create-vite</code> 则使用 Rollup 来构建生产代码。Rollup 是一个专注于构建 JavaScript 库的工具，通常被认为比 Webpack 更适合用于构建库和框架。</li></ol><p>总的来说，<code>create-vite</code> 相对于 <code>create-react-app</code> 更加轻量、快速，尤其适合于构建 Vue.js 项目或者需要更快速开发体验的应用程序。但在选择工具时，还应考虑到项目的具体需求和团队的熟悉程度。</p>]]></content:encoded>
      
      
      <category domain="https://sharpmind.tech/categories/%E5%89%8D%E7%AB%AF/">前端</category>
      
      
      <category domain="https://sharpmind.tech/tags/vite/">vite</category>
      
      <category domain="https://sharpmind.tech/tags/npm-create/">npm create</category>
      
      <category domain="https://sharpmind.tech/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/">前端工具</category>
      
      
    </item>
    
    <item>
      <title>Shell 常用命令总结</title>
      <link>https://sharpmind.tech/Shell-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</link>
      <guid>https://sharpmind.tech/Shell-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</guid>
      <pubDate>Thu, 04 Sep 2025 03:50:29 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;总结一下shell最常用的命令，不断更新&lt;/p&gt;
&lt;h2 id=&quot;echo命令&quot;&gt;&lt;a href=&quot;#echo命令&quot; class=&quot;headerlink&quot; title=&quot;echo命令&quot;&gt;&lt;/a&gt;echo命令&lt;/h2&gt;&lt;p&gt;你可以使用 &lt;code&gt;echo&lt;/code&gt;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>总结一下shell最常用的命令，不断更新</p><h2 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h2><p>你可以使用 <code>echo</code> 命令并通过 <code>&gt;&gt;</code> 追加数据到文件末尾。例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;追加的内容&quot;</span> &gt;&gt; 文件名</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><p><strong>向 <code>myfile.txt</code> 追加一行文本</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;这是新追加的内容&quot;</span> &gt;&gt; myfile.txt</span><br></pre></td></tr></table></figure><p><strong>向 <code>myfile.txt</code> 追加多行内容</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;第一行\n第二行\n第三行&quot;</span> &gt;&gt; myfile.txt</span><br></pre></td></tr></table></figure><ul><li><code>-e</code> 选项用于启用 <code>\n</code> 换行符。</li></ul><p><strong>追加当前日期时间</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(date)</span> - 日志内容&quot;</span> &gt;&gt; log.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://sharpmind.tech/categories/Shell/">Shell</category>
      
      
      <category domain="https://sharpmind.tech/tags/shell/">shell</category>
      
      <category domain="https://sharpmind.tech/tags/linux/">linux</category>
      
      
    </item>
    
    <item>
      <title>Ubuntu22 上如何查看docker 的运行情况</title>
      <link>https://sharpmind.tech/Ubuntu22-%E4%B8%8A%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8Bdocker-%E7%9A%84%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5/</link>
      <guid>https://sharpmind.tech/Ubuntu22-%E4%B8%8A%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8Bdocker-%E7%9A%84%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5/</guid>
      <pubDate>Tue, 02 Sep 2025 15:04:23 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;在 &lt;strong&gt;Ubuntu 22.04&lt;/strong&gt; 上查看 Docker 的运行情况，我们可以从 &lt;strong&gt;服务状态&lt;/strong&gt;、&lt;strong&gt;容器运行情况&lt;/strong&gt;、&lt;strong&gt;日志&lt;/strong&gt;</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>在 <strong>Ubuntu 22.04</strong> 上查看 Docker 的运行情况，我们可以从 <strong>服务状态</strong>、<strong>容器运行情况</strong>、<strong>日志</strong> 等几个角度来检查。下面是整理几个常用方法：</p><hr><h2 id="1️⃣-查看-Docker-服务是否正常运行"><a href="#1️⃣-查看-Docker-服务是否正常运行" class="headerlink" title="1️⃣ 查看 Docker 服务是否正常运行"></a>1️⃣ 查看 Docker 服务是否正常运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure><ul><li><code>active (running)</code> 表示 Docker 服务正在运行。</li><li>如果没有运行，可以启动：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start docker</span><br></pre></td></tr></table></figure><p>并设置开机自启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><hr><h2 id="2️⃣-查看正在运行的容器"><a href="#2️⃣-查看正在运行的容器" class="headerlink" title="2️⃣ 查看正在运行的容器"></a>2️⃣ 查看正在运行的容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><ul><li>会列出所有正在运行的容器，包括容器 ID、镜像、端口映射等。</li></ul><p>如果想查看<strong>所有容器</strong>（包括已停止的）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><hr><h2 id="3️⃣-查看容器资源占用情况"><a href="#3️⃣-查看容器资源占用情况" class="headerlink" title="3️⃣ 查看容器资源占用情况"></a>3️⃣ 查看容器资源占用情况</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stats</span><br></pre></td></tr></table></figure><ul><li>实时显示 CPU、内存、网络、I&#x2F;O 占用情况，类似 <code>top</code> 命令。</li></ul><hr><h3 id="4️⃣-查看-Docker-日志"><a href="#4️⃣-查看-Docker-日志" class="headerlink" title="4️⃣ 查看 Docker 日志"></a>4️⃣ 查看 Docker 日志</h3><p>查看 Docker 服务日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -u docker -f</span><br></pre></td></tr></table></figure><ul><li><code>-f</code> 表示实时跟随日志。</li></ul><p>查看某个容器的日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f &lt;容器ID或容器名&gt;</span><br></pre></td></tr></table></figure><hr><h2 id="5️⃣-查看-Docker-信息和环境"><a href="#5️⃣-查看-Docker-信息和环境" class="headerlink" title="5️⃣ 查看 Docker 信息和环境"></a>5️⃣ 查看 Docker 信息和环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure><ul><li>可以看到 Docker 的运行环境、容器数量、镜像数量、存储驱动等信息。</li></ul>]]></content:encoded>
      
      
      <category domain="https://sharpmind.tech/categories/Docker/">Docker</category>
      
      
      
    </item>
    
    <item>
      <title>关于git pull时的警告</title>
      <link>https://sharpmind.tech/%E5%85%B3%E4%BA%8Egit-pull%E6%97%B6%E7%9A%84%E8%AD%A6%E5%91%8A/</link>
      <guid>https://sharpmind.tech/%E5%85%B3%E4%BA%8Egit-pull%E6%97%B6%E7%9A%84%E8%AD%A6%E5%91%8A/</guid>
      <pubDate>Wed, 05 Mar 2025 06:00:01 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;当我们在git pull时，有时可能会遇到以下警告：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>当我们在git pull时，有时可能会遇到以下警告：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">warning: 不建议在没有为偏离分支指定合并策略时执行 pull 操作。 您可以在执行下一次</span><br><span class="line">pull 操作之前执行下面一条命令来抑制本消息：</span><br><span class="line"></span><br><span class="line">  git config pull.rebase <span class="literal">false</span>  <span class="comment"># 合并（缺省策略）</span></span><br><span class="line">  git config pull.rebase <span class="literal">true</span>   <span class="comment"># 变基</span></span><br><span class="line">  git config pull.ff only       <span class="comment"># 仅快进</span></span><br><span class="line"></span><br><span class="line">您可以将 <span class="string">&quot;git config&quot;</span> 替换为 <span class="string">&quot;git config --global&quot;</span> 以便为所有仓库设置</span><br><span class="line">缺省的配置项。您也可以在每次执行 pull 命令时添加 --rebase、--no-rebase，</span><br><span class="line">或者 --ff-only 参数覆盖缺省设置。</span><br></pre></td></tr></table></figure><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>这个警告的意思是：Git 需要你指定 git pull 时如何处理远程和本地的变更，否则会给出提示。</p><p>你可以在 git pull 时选择以下三种模式：</p><ul><li>1️⃣ 合并（默认）</li><li>2️⃣ 变基（rebase）</li><li>3️⃣ 仅快进（ff only）</li></ul><p>不同模式适用于不同的工作流，我们来分析一下。👇</p><h2 id="⌛️-git-config-pull-rebase-false（默认合并模式）"><a href="#⌛️-git-config-pull-rebase-false（默认合并模式）" class="headerlink" title="⌛️ git config pull.rebase false（默认合并模式）"></a>⌛️ git config pull.rebase false（默认合并模式）</h2><p><img src="https://cdn.sanity.io/images/1y08pmef/production/171874bbb2327e202869a210f7cdebbc0d9ee5c6-800x539.webp" alt="git pull"></p><p>适合：多人协作，分支合并时不在意 commit 历史</p><p>git pull 时，会创建一个 合并（merge）提交，保持分支历史完整。</p><p>但：如果你经常 pull，可能会出现很多“无意义的 merge commit”。</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global pull.rebase <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#或</span></span><br><span class="line"></span><br><span class="line">git pull --no-rebase</span><br></pre></td></tr></table></figure><p>✅ 优点：</p><p>适合大部分 Git 用户（默认行为）。<br>能完整保留所有 commit 历史，适用于多人合作的仓库。</p><p>❌ 缺点：</p><p>可能会导致 commit 历史混乱，出现大量 “Merge branch ‘main’” 提交。</p><h2 id="⏰-git-config-pull-rebase-true（变基模式）"><a href="#⏰-git-config-pull-rebase-true（变基模式）" class="headerlink" title="⏰ git config pull.rebase true（变基模式）"></a>⏰ git config pull.rebase true（变基模式）</h2><p><img src="https://cdn.sanity.io/images/1y08pmef/production/9d0a66e8d09c945df4123e7dcc75221600ed70de-800x677.webp" alt="git pull --rebase"></p><p>适合：想保持清晰线性历史、不喜欢 merge commit</p><p>git pull 时，会 把你的本地 commit 重新应用到最新的远程分支上，不会产生额外的合并提交。<br>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global pull.rebase <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#或</span></span><br><span class="line"></span><br><span class="line">git pull --rebase</span><br></pre></td></tr></table></figure><p>✅ 优点：</p><p>保持 commit 历史整洁，不会出现多余的 merge commit。<br>适合 个人开发 或 希望历史记录保持线性 的团队。</p><p>❌ 缺点：</p><p>如果本地有改动，可能需要 手动解决冲突，变基比合并稍复杂。</p><h2 id="🧭-git-config-pull-ff-only（仅快进模式）"><a href="#🧭-git-config-pull-ff-only（仅快进模式）" class="headerlink" title="🧭 git config pull.ff only（仅快进模式）"></a>🧭 git config pull.ff only（仅快进模式）</h2><p>适合：不想自动创建合并提交，保证提交历史清晰</p><p>只有在远程仓库的分支 是你本地分支的直接后继 时，才会合并。<br>如果远程分支有新的 commit 而本地也有改动，pull 会失败，提示你需要手动处理。<br>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global pull.ff only</span><br><span class="line"></span><br><span class="line"><span class="comment">#或</span></span><br><span class="line"></span><br><span class="line">git pull --ff-only</span><br></pre></td></tr></table></figure><p>✅ 优点：</p><p>保证 Git 历史干净，不会意外创建合并提交。<br>如果 pull 失败，意味着你需要手动 rebase 或 merge，避免错误合并。</p><p>❌ 缺点：</p><p>不适合 多人协作的开发，因为如果本地和远程有分叉，它不会自动合并。</p><h2 id="📟-选择哪种方式？"><a href="#📟-选择哪种方式？" class="headerlink" title="📟 选择哪种方式？"></a>📟 选择哪种方式？</h2><table><thead><tr><th>选择</th><th>适用场景</th><th>适合人群</th><th>历史是否干净</th></tr></thead><tbody><tr><td>pull.rebase false（默认合并）</td><td>多人协作，默认合并提交</td><td>初学者 &amp; 团队协作</td><td>❌ 可能会有多余的 merge commit</td></tr><tr><td>pull.rebase true（变基）</td><td>线性历史，不想要 merge commit</td><td>个人开发 &amp; 代码清理控</td><td>✅ 更干净，但可能需要解决冲突</td></tr><tr><td>pull.ff only（仅快进）</td><td>严格控制历史，不允许意外 merge</td><td>代码风格严格的团队</td><td>✅ 非常干净，但 pull 失败率较高</td></tr></tbody></table><h2 id="💡-建议"><a href="#💡-建议" class="headerlink" title="💡 建议"></a>💡 建议</h2><p>👉 如果你是团队协作开发（推荐默认合并模式）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global pull.rebase <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>这样不会因为 git pull 影响团队的历史记录，大家更容易管理。</p><p>👉 如果你个人开发，想保持整洁历史（推荐变基模式）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global pull.rebase <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这样 git pull 不会产生多余的 merge commit，让 commit 历史保持线性。</p><p>👉 如果你想严格控制合并，不允许 merge commit（推荐仅快进模式）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global pull.ff only</span><br></pre></td></tr></table></figure><p>这样 Git 只会快进合并，遇到冲突会要求你手动处理。</p><hr><p>如果你不确定用哪种，可以先用默认的 false，然后在需要时手动使用 <code>--rebase</code> 或 <code>--ff-only</code>！🚀</p>]]></content:encoded>
      
      
      <category domain="https://sharpmind.tech/categories/%E8%BF%90%E7%BB%B4%E9%83%A8%E7%BD%B2/">运维部署</category>
      
      
      <category domain="https://sharpmind.tech/tags/git/">git</category>
      
      
    </item>
    
    <item>
      <title>Github Actions + 服务器 SSH配置自动化打包流程</title>
      <link>https://sharpmind.tech/Github-Actions-%E6%9C%8D%E5%8A%A1%E5%99%A8-SSH%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/</link>
      <guid>https://sharpmind.tech/Github-Actions-%E6%9C%8D%E5%8A%A1%E5%99%A8-SSH%E9%85%8D%E7%BD%AE%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/</guid>
      <pubDate>Tue, 04 Mar 2025 05:57:59 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;如果我们有个小型的项目，运行在自己的服务器上，一般开发流程是本地开发，推送到github，然后自己手动登录服务器，拉取最新的代码并打包，然后把打出的包上线。&lt;/p&gt;
&lt;p&gt;我们希望当我们在github上 push 代码的时候，github</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>如果我们有个小型的项目，运行在自己的服务器上，一般开发流程是本地开发，推送到github，然后自己手动登录服务器，拉取最新的代码并打包，然后把打出的包上线。</p><p>我们希望当我们在github上 push 代码的时候，github 能够自动通知服务器拉取最新的代码并打包，然后把打出的包上线。此时我们不用专门去搭建一套CI&#x2F;CD系统（比如jenkins、gitlab ci）。</p><p>最简单的方式可以怎么做呢？我们可以使用GitHub Actions来实现这个需求，具体方案如下。</p><h2 id="步骤-1：配置-GitHub-Secrets"><a href="#步骤-1：配置-GitHub-Secrets" class="headerlink" title="步骤 1：配置 GitHub Secrets"></a>步骤 1：配置 GitHub Secrets</h2><p>在 GitHub 仓库 设置：</p><ol><li>Settings → Secrets and variables → Actions → New repository secret</li><li>添加：<ul><li><code>SSH_HOST = your-server-ip</code> # 服务器IP</li><li><code>SSH_USER = your-username</code> # 服务器用户名</li><li><code>SSH_KEY = 你的 SSH 私钥（用 cat ~/.ssh/id_rsa 复制粘贴）</code> # 你的开发机SSH私钥</li></ul></li></ol><p>在 github 的actions 里面 有 两个tab： secrets 和 variables </p><ul><li>Secrets（机密信息） 👉 存放 敏感数据（如 SSH Key）</li><li>Variables（变量） 👉 存放 普通变量（如路径、环境变量等）</li></ul><p>:::tip<br>SSH_KEY 是你的开发机SSH私钥，而不是服务器的SSH私钥。还有是私钥不是公钥。<br>::: </p><p>如果你不会生成SSH私钥，可以参考<a href="/blog/manage-multiple-ssh-keys">这篇文章</a>。</p><h2 id="步骤-2：创建-GitHub-Actions-工作流"><a href="#步骤-2：创建-GitHub-Actions-工作流" class="headerlink" title="步骤 2：创建 GitHub Actions 工作流"></a>步骤 2：创建 GitHub Actions 工作流</h2><p>在仓库根目录创建 <code>.github/workflows/deploy.yml</code> 文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">Server</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">code</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">via</span> <span class="string">SSH</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">appleboy/ssh-action@v0.1.10</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">host:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SSH_HOST</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">username:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SSH_USER</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SSH_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">script:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            # 进入项目目录</span></span><br><span class="line"><span class="string">            cd /var/www/your-project-name </span></span><br><span class="line"><span class="string"></span></span><br><span class="line">            <span class="comment"># 拉取最新代码</span></span><br><span class="line">            <span class="string">git</span> <span class="string">pull</span> <span class="string">origin</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 安装依赖</span></span><br><span class="line">            <span class="string">pnpm</span> <span class="string">install</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 执行构建</span></span><br><span class="line">            <span class="string">pnpm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 获取目标目录和备份目录</span></span><br><span class="line">            <span class="string">TARGET_DIR=&quot;$&#123;&#123;</span> <span class="string">vars.TARGET_DIR</span> <span class="string">&#125;&#125;&quot;</span></span><br><span class="line">            <span class="string">BACKUP_DIR=&quot;$&#123;&#123;</span> <span class="string">vars.BACKUP_DIR</span> <span class="string">&#125;&#125;&quot;</span></span><br><span class="line">            <span class="string">SOURCE_DIR=&quot;$&#123;&#123;</span> <span class="string">vars.SOURCE_DIR</span> <span class="string">&#125;&#125;&quot;</span></span><br><span class="line">            <span class="comment"># 备份旧目录</span></span><br><span class="line">            <span class="string">if</span> [ <span class="string">-d</span> <span class="string">&quot;$TARGET_DIR&quot;</span> ]<span class="string">;</span> <span class="string">then</span></span><br><span class="line">                <span class="string">echo</span> <span class="string">&quot;检测到 $TARGET_DIR 存在，备份到 $BACKUP_DIR&quot;</span></span><br><span class="line">                <span class="string">mv</span> <span class="string">&quot;$TARGET_DIR&quot;</span> <span class="string">&quot;$BACKUP_DIR&quot;</span></span><br><span class="line">            <span class="string">fi</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 复制新构建的 build 目录</span></span><br><span class="line">            <span class="string">cp</span> <span class="string">-r</span> <span class="string">&quot;$SOURCE_DIR&quot;</span> <span class="string">&quot;$TARGET_DIR&quot;</span></span><br><span class="line"></span><br><span class="line">            <span class="string">echo</span> <span class="string">&quot;部署完成 🎉&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="步骤-3（可选）：添加环境变量"><a href="#步骤-3（可选）：添加环境变量" class="headerlink" title="步骤 3（可选）：添加环境变量"></a>步骤 3（可选）：添加环境变量</h2><p>上面代码里面，我们用到了 3 个环境变量：</p><ul><li><code>PROJECT_DIR = /var/www/your-project-name</code>  # 你的项目目录</li><li><code>DEPLOY_DIR = /var/www/public/your-project-name</code>  # 部署到服务器的目录</li><li><code>SOURCE_DIR = /var/www/your-project-name/dist</code>  # 构建产物目录</li></ul><p>如果你有 不敏感的环境变量，可以添加到 Variables（变量）：</p><p>进入 Settings → Secrets and variables → Actions → Variables</p><p>点击 New repository variable</p><p>添加如下内容（可选）：</p><ul><li><code>PROJECT_DIR = /var/www/your-project-name</code>  # 你的项目目录</li><li><code>DEPLOY_DIR = /var/www/public/your-project-name</code>  # 部署到服务器的目录</li><li><code>SOURCE_DIR = /var/www/your-project-name/dist</code>  # 构建产物目录</li></ul><p>:::tip<br>PROJECT_DIR 是你的项目目录，DEPLOY_DIR 是你的部署目录。SOURCE_DIR 是你的构建产物目录。</p><p>这些都是针对服务器的目录。 不是你的本地目录。<br>::: </p><h2 id="步骤-4：查看-GitHub-Actions-运行状态"><a href="#步骤-4：查看-GitHub-Actions-运行状态" class="headerlink" title="步骤 4：查看 GitHub Actions 运行状态"></a>步骤 4：查看 GitHub Actions 运行状态</h2><ol><li>进入 GitHub 仓库</li><li>点击 “Actions” 标签</li><li>你会看到 Deploy to Server 的运行记录</li><li>如果部署失败，点击进日志查看具体错误信息</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上步骤，你就可以实现 GitHub Actions 自动化部署到服务器了。</p>]]></content:encoded>
      
      
      <category domain="https://sharpmind.tech/categories/%E8%BF%90%E7%BB%B4%E9%83%A8%E7%BD%B2/">运维部署</category>
      
      
      <category domain="https://sharpmind.tech/tags/github/">github</category>
      
      <category domain="https://sharpmind.tech/tags/ssh/">ssh</category>
      
      <category domain="https://sharpmind.tech/tags/%E8%87%AA%E5%8A%A8%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/">自动打包流程</category>
      
      
    </item>
    
    <item>
      <title>同一台电脑管理多个 SSH Key</title>
      <link>https://sharpmind.tech/%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AA-SSH-Key/</link>
      <guid>https://sharpmind.tech/%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AA-SSH-Key/</guid>
      <pubDate>Mon, 03 Mar 2025 05:55:10 GMT</pubDate>
      
        
        
          
          
      <description>&lt;h2 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h2&gt;&lt;p&gt;在同一台电脑上，可能需要管理多个 SSH</description>
          
        
      
      
      
      <content:encoded><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在同一台电脑上，可能需要管理多个 SSH Key，例如：</p><ul><li>一个用于个人项目</li><li>一个用于工作项目</li></ul><p>但是又不想切换各种配置文件，那么就可以使用本文的方法。</p><h2 id="生成-SSH-key"><a href="#生成-SSH-key" class="headerlink" title="生成 SSH key"></a>生成 SSH key</h2><p>在终端执行以下命令（推荐使用 <code>ed25519</code> 算法）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure><p>如果你需要兼容旧系统，可以使用 <code>rsa</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure><ul><li><code>-t ed25519</code>：使用更安全的 <code>ed25519</code> 算法</li><li><code>-b 4096</code>：如果使用 <code>rsa</code>，建议 4096 位密钥</li><li><code>-C &quot;your_email@example.com&quot;</code>：为 SSH Key 添加备注（通常是你的邮箱）</li></ul><p>执行上面的命令后系统会提示你选择存储路径，默认存储在 <code>~/.ssh/id_ed25519</code>（或 &#96;&#96;~&#x2F;.ssh&#x2F;id_rsa&#96;）。直接回车使用默认路径，或输入自定义路径。</p><p>你可以为 SSH Key 设置密码，增加安全性（如果不想设置，直接回车）。</p><p>添加 SSH Key 到 ssh-agent</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(ssh-agent -s)</span>&quot;</span>  <span class="comment"># 启动 ssh-agent</span></span><br><span class="line">ssh-add ~/.ssh/id_ed25519  <span class="comment"># 添加密钥（如果是 RSA 则是 id_rsa）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>复制 SSH 公钥</p><p>执行以下命令复制公钥：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_ed25519.pub | pbcopy  <span class="comment"># macOS</span></span><br><span class="line"><span class="built_in">cat</span> ~/.ssh/id_ed25519.pub | xclip -sel clip  <span class="comment"># Linux（需安装 xclip）</span></span><br><span class="line"><span class="built_in">cat</span> ~/.ssh/id_ed25519.pub  <span class="comment"># Windows 或手动复制</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后将公钥粘贴到 GitHub、GitLab、服务器等的 <strong>SSH Key</strong> 设置中。</p><p>测试 SSH 连接</p><p>例如，测试 GitHub：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果成功，你会看到类似：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi username! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure><p>完成！你现在可以使用 SSH 连接 Git、服务器等。🚀</p><h2 id="生成两个-SSH-Key"><a href="#生成两个-SSH-Key" class="headerlink" title="生成两个 SSH Key"></a>生成两个 SSH Key</h2><p>为两个账户分别生成 SSH Key（这里以 <code>work@example.com</code> 和 <code>personal@example.com</code> 为例）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C <span class="string">&quot;work@example.com&quot;</span> -f ~/.ssh/id_ed25519_work</span><br><span class="line">ssh-keygen -t ed25519 -C <span class="string">&quot;personal@example.com&quot;</span> -f ~/.ssh/id_ed25519_personal</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>添加 SSH Key 到 ssh-agent,启动 <code>ssh-agent</code> 并添加两个 SSH Key：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(ssh-agent -s)</span>&quot;</span></span><br><span class="line">ssh-add ~/.ssh/id_ed25519_work</span><br><span class="line">ssh-add ~/.ssh/id_ed25519_personal</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置 <code>~/.ssh/config</code></p><p>在 <code>~/.ssh/config</code>（没有就创建一个）中添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># GitHub 工作账号</span><br><span class="line">Host github-work</span><br><span class="line">    HostName github.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile ~/.ssh/id_ed25519_work</span><br><span class="line"></span><br><span class="line"># GitHub 个人账号</span><br><span class="line">Host github-personal</span><br><span class="line">    HostName github.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile ~/.ssh/id_ed25519_personal</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>这个配置的作用是：</strong></p><ul><li>当你访问 <code>github-work</code>，使用 <code>id_ed25519_work</code></li><li>当你访问 <code>github-personal</code>，使用 <code>id_ed25519_personal</code></li></ul><p>添加 SSH Key 到 GitHub</p><p>运行以下命令，分别复制公钥，并添加到对应 GitHub 账号的 <strong>SSH Keys</strong> 里：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_ed25519_work.pub</span><br><span class="line"><span class="built_in">cat</span> ~/.ssh/id_ed25519_personal.pub</span><br></pre></td></tr></table></figure><ul><li>登录 GitHub，进入 <strong>Settings → SSH and GPG keys</strong>，添加相应的公钥。</li></ul><p>克隆或修改 Git 远程仓库</p><p>如果你需要分别使用不同账号，你需要使用 <code>git@github-work</code> 或 <code>git@github-personal</code>。</p><p><strong>示例 1：克隆仓库</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github-personal:your-personal-username/personal-repo.git</span><br><span class="line">git <span class="built_in">clone</span> git@github-work:your-work-username/work-repo.git</span><br></pre></td></tr></table></figure><p><strong>示例 2：修改已存在仓库的远程地址</strong> 进入已有项目文件夹，运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@github-work:your-work-username/work-repo.git</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@github-personal:your-personal-username/personal-repo.git</span><br></pre></td></tr></table></figure><h2 id="可能会出现的问题"><a href="#可能会出现的问题" class="headerlink" title="可能会出现的问题"></a>可能会出现的问题</h2><p>已经把ssh key 放到 Github 了，但是本地推送代码提示:<br><code>git push --set-upstream origin main ERROR: Repository not found. fatal: 无法读取远程仓库。</code></p><p>你的错误信息 <code>ERROR: Repository not found.</code>（找不到仓库）和 <code>无法读取远程仓库</code> 可能是由以下几个原因导致的：</p><h3 id="第一种-远程仓库-URL-配置错误"><a href="#第一种-远程仓库-URL-配置错误" class="headerlink" title="第一种 远程仓库 URL 配置错误"></a>第一种 远程仓库 URL 配置错误</h3><p>先检查你当前项目的 Git 远程仓库地址：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>如果你看到的是 HTTPS 地址，例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">origin  https://github.com/your-username/repo-name.git (fetch)</span><br><span class="line">origin  https://github.com/your-username/repo-name.git (push)</span><br></pre></td></tr></table></figure><p>这说明你在用 HTTPS，而 SSH Key 只对 SSH 地址有效。</p><p>解决方案：修改为 SSH 地址</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@github.com:your-username/repo-name.git</span><br></pre></td></tr></table></figure><p>然后再尝试推送</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin main</span><br></pre></td></tr></table></figure><h3 id="第二种-SSH-Key-未正确加载"><a href="#第二种-SSH-Key-未正确加载" class="headerlink" title="第二种 SSH Key 未正确加载"></a>第二种 SSH Key 未正确加载</h3><p>你可能需要手动添加你的 SSH Key 到 <code>ssh-agent</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(ssh-agent -s)</span>&quot;</span></span><br><span class="line">ssh-add ~/.ssh/id_ed25519  <span class="comment"># 你的 SSH Key 路径，可能是 id_rsa</span></span><br></pre></td></tr></table></figure><p>然后测试 SSH 连接：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>如果成功，你会看到：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi your-username! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure><p>如果失败，说明你的 SSH Key 可能没有正确配置到 GitHub。</p><p>如果你已经在 <code>~/.ssh/config</code> 中配置了，但是依然报错，很有可能是：</p><p>即使 <code>~/.ssh/config</code> 配置了 <code>IdentityFile</code>，SSH 可能不会自动加载 Key，特别是在 <strong>macOS 或某些 Linux 发行版</strong> 上。你可以尝试手动查看 <code>ssh-agent</code> 是否已经加载了你的 Key：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add -l</span><br></pre></td></tr></table></figure><p>如果返回 <code>The agent has no identities</code>，说明 <code>ssh-agent</code> 没有加载任何 Key。你需要手动添加：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_ed25519_work</span><br><span class="line">ssh-add ~/.ssh/id_ed25519_personal</span><br></pre></td></tr></table></figure><p>如果每次重启后 Key 仍然丢失，你可以让 <code>ssh-agent</code> <strong>永久记住 SSH Key</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-add --apple-use-keychain ~/.ssh/id_ed25519_work  # 适用于 macOS</span><br><span class="line">ssh-add -K ~/.ssh/id_ed25519_work                    # macOS 旧版本</span><br><span class="line">ssh-add ~/.ssh/id_ed25519_work                       # Linux</span><br></pre></td></tr></table></figure><h3 id="ssh-v"><a href="#ssh-v" class="headerlink" title="ssh-v"></a>ssh-v</h3><p><code>ssh -v</code>（<strong>verbose 模式</strong>）用于 <strong>调试 SSH 连接</strong>，查看 SSH 具体使用了哪个 Key 进行认证。</p><p>👉 <strong>调试 SSH 连接</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -vT git@github.com</span><br></pre></td></tr></table></figure><p>输出内容会显示：</p><ul><li>SSH 连接的详细过程</li><li>是否使用了正确的 SSH Key</li><li>SSH 认证是否成功</li></ul><p>如果你在调试多个 SSH Key，可以运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -vT github-work</span><br><span class="line">ssh -vT github-personal</span><br></pre></td></tr></table></figure><p>这可以帮助你确认 SSH 是否走了正确的 Key。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如果 <code>~/.ssh/config</code> 没生效，可以依次尝试： </p><p>✅ 1. <strong>检查 <code>ssh-agent</code> 是否正确加载 Key</strong> (<code>ssh-add -l</code>)<br>✅ 2. <strong>确保 Git 远程仓库使用的是 SSH 地址</strong> (<code>git remote -v</code>)<br>✅ 3. <strong>测试 SSH 连接是否走对了 Key</strong> (<code>ssh -vT github-work</code>)<br>✅ 4. <strong>确认 GitHub 账户里添加了正确的 SSH Key</strong><br>✅ 5. <strong>让 <code>ssh-agent</code> 自动加载 Key，避免重启丢失</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>eval “$(ssh-agent -s)”</td><td>启动 ssh-agent，让 SSH Key 在当前会话中生效</td></tr><tr><td>ssh-add ~&#x2F;.ssh&#x2F;id_ed25519_work</td><td>手动添加 SSH Key 到 ssh-agent</td></tr><tr><td>ssh-add -l</td><td>查看 ssh-agent 已加载的 SSH Key</td></tr><tr><td>ssh -T <a href="mailto:&#103;&#105;&#116;&#64;&#103;&#105;&#x74;&#x68;&#117;&#x62;&#x2e;&#99;&#111;&#x6d;">git@github.com</a></td><td>测试 SSH 连接是否成功</td></tr><tr><td>ssh -vT <a href="mailto:&#x67;&#105;&#116;&#x40;&#103;&#x69;&#x74;&#104;&#x75;&#x62;&#46;&#x63;&#x6f;&#x6d;">git@github.com</a></td><td>详细调试 SSH 连接</td></tr><tr><td>git remote -v</td><td>查看 Git 远程仓库地址</td></tr><tr><td>git remote set-url origin <a href="mailto:&#x67;&#105;&#116;&#64;&#103;&#105;&#x74;&#x68;&#x75;&#x62;&#46;&#99;&#111;&#109;">git@github.com</a>:your-username&#x2F;repo-name.git</td><td>修改 Git 远程仓库为 SSH</td></tr><tr><td>cat ~&#x2F;.ssh&#x2F;id_ed25519.pub</td><td>查看 SSH 公钥并添加到 GitHub</td></tr><tr><td>~&#x2F;.ssh&#x2F;config</td><td>配置多个 SSH Key，自动匹配不同账号</td></tr></tbody></table>]]></content:encoded>
      
      
      <category domain="https://sharpmind.tech/categories/%E8%BF%90%E7%BB%B4%E9%83%A8%E7%BD%B2/">运维部署</category>
      
      
      <category domain="https://sharpmind.tech/tags/github/">github</category>
      
      <category domain="https://sharpmind.tech/tags/ssh/">ssh</category>
      
      <category domain="https://sharpmind.tech/tags/ssh-key/">ssh key</category>
      
      
    </item>
    
    <item>
      <title>API 路由设计规范 RESTful API</title>
      <link>https://sharpmind.tech/API-%E8%B7%AF%E7%94%B1%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83-RESTful-API/</link>
      <guid>https://sharpmind.tech/API-%E8%B7%AF%E7%94%B1%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83-RESTful-API/</guid>
      <pubDate>Sun, 27 Oct 2024 11:45:44 GMT</pubDate>
      
        
        
          
          
      <description>&lt;p&gt;在 RESTful API 的设计中，将登录和注册 API 放在 &lt;code&gt;users&lt;/code&gt; 路由下并不是不可以，但有更清晰、更符合语义化规范的方式来组织这些路由。以下是一些业界常见的设计方案和规范建议：&lt;/p&gt;
&lt;hr&gt;
&lt;h2</description>
          
        
      
      
      
      <content:encoded><![CDATA[<p>在 RESTful API 的设计中，将登录和注册 API 放在 <code>users</code> 路由下并不是不可以，但有更清晰、更符合语义化规范的方式来组织这些路由。以下是一些业界常见的设计方案和规范建议：</p><hr><h2 id="1-根据资源和动作分开路由"><a href="#1-根据资源和动作分开路由" class="headerlink" title="1. 根据资源和动作分开路由"></a>1. <strong>根据资源和动作分开路由</strong></h2><ul><li><strong>用户的 CRUD 操作</strong>放在 <code>/users</code> 路由下。</li><li><strong>登录和注册</strong>属于认证和授权的功能，不直接操作用户资源，建议单独归为一类。</li></ul><h3 id="路由建议："><a href="#路由建议：" class="headerlink" title="路由建议："></a>路由建议：</h3><ul><li>用户相关（CRUD）：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">GET    /api/v1/users          - 获取用户列表</span><br><span class="line">GET    /api/v1/users/:<span class="built_in">id</span>      - 获取特定用户</span><br><span class="line">POST   /api/v1/users          - 创建用户</span><br><span class="line">PUT    /api/v1/users/:<span class="built_in">id</span>      - 更新用户信息</span><br><span class="line">DELETE /api/v1/users/:<span class="built_in">id</span>      - 删除用户</span><br></pre></td></tr></table></figure><ul><li>认证相关（Auth）：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST   /api/v1/auth/register  - 用户注册</span><br><span class="line">POST   /api/v1/auth/login     - 用户登录</span><br><span class="line">POST   /api/v1/auth/logout    - 用户注销</span><br><span class="line">POST   /api/v1/auth/refresh   - 刷新 Token</span><br></pre></td></tr></table></figure><p>这样分开设计的好处：</p><ul><li><strong>语义化更强</strong>：<code>/auth</code> 路由明确了这是关于认证的。</li><li><strong>职责清晰</strong>：<code>users</code> 负责用户资源的管理，<code>auth</code> 负责认证流程。</li></ul><hr><h2 id="2-控制器层的职责分离"><a href="#2-控制器层的职责分离" class="headerlink" title="2. 控制器层的职责分离"></a>2. <strong>控制器层的职责分离</strong></h2><p>你目前将登录和注册逻辑放在了 <code>usersController</code> 中，这是因为两者都涉及用户资源。但更好的做法是根据职责拆分控制器：</p><ul><li><code>usersController</code> 专注于用户资源的 CRUD 操作。</li><li><code>authController</code> 专注于登录、注册等认证逻辑。</li></ul><h3 id="示例代码结构："><a href="#示例代码结构：" class="headerlink" title="示例代码结构："></a>示例代码结构：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// routes/authRoutes.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; login, register &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../controllers/authController&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/login&#x27;</span>, login);</span><br><span class="line">router.<span class="title function_">post</span>(<span class="string">&#x27;/register&#x27;</span>, register);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br><span class="line"></span><br><span class="line"><span class="comment">// routes/userRoutes.js</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; getAllUsers, getUserById, updateUser, deleteUser &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../controllers/usersController&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> router = express.<span class="title class_">Router</span>();</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, getAllUsers);</span><br><span class="line">router.<span class="title function_">get</span>(<span class="string">&#x27;/:id&#x27;</span>, getUserById);</span><br><span class="line">router.<span class="title function_">put</span>(<span class="string">&#x27;/:id&#x27;</span>, updateUser);</span><br><span class="line">router.<span class="title function_">delete</span>(<span class="string">&#x27;/:id&#x27;</span>, deleteUser);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router;</span><br></pre></td></tr></table></figure><hr><h2 id="3-实际使用案例"><a href="#3-实际使用案例" class="headerlink" title="3. 实际使用案例"></a>3. <strong>实际使用案例</strong></h2><p>在许多成熟的项目或框架中，这种分离方式是主流：</p><ul><li><strong>Node.js</strong> 社区（如 Express 应用程序模板）：通常将 <code>auth</code> 和 <code>users</code> 拆分成不同模块。</li><li><strong>大型开源项目</strong>（如 Laravel、Django、Spring）：同样将认证逻辑与资源逻辑分离。</li></ul><hr><h2 id="总结建议"><a href="#总结建议" class="headerlink" title="总结建议"></a>总结建议</h2><ul><li>使用 <code>/api/v1/auth/login</code> 和 <code>/api/v1/auth/register</code> 作为登录和注册的路由。</li><li>将认证逻辑（如登录、注册）移入 <code>authController</code>，用户资源管理逻辑保留在 <code>usersController</code>。</li><li>在项目结构中保持模块化和职责分离，便于扩展和维护。</li></ul><p>这样设计符合业界规范，同时对未来添加更多认证功能（如密码重置、OAuth 登录）也更加友好。</p>]]></content:encoded>
      
      
      
      
    </item>
    
  </channel>
</rss>
